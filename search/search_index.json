{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue sur le site NSI du lyc\u00e9e Claveille \u00e0 P\u00e9rigueux.","title":"Home"},{"location":"#bienvenue-sur-le-site-nsi-du-lycee-claveille-a-perigueux","text":"","title":"Bienvenue sur le site NSI du lyc\u00e9e Claveille \u00e0 P\u00e9rigueux."},{"location":"aide/","text":"Aide markdown : https://ens-fr.gitlab.io/mkdocs/markdown-bases/ https://sourcefoundry.org/cinder/ https://bouillotvincent.gitlab.io/pyodide-mkdocs/#introduction https://ferney-nsi.gitlab.io/premiere/chapitre1/","title":"Aide"},{"location":"1_Langage%20et%20programmation/Base_python/","text":"Structures de base d\u2019un programme Format PDF Un programme est un texte qui d\u00e9crit un algorithme que l\u2019on souhaite faire ex\u00e9cuter par une machine. Ce texte est \u00e9crit dans un langage particulier, appel\u00e9 langage de programmation. Il existe plusieurs milliers de langages de programmation, parmi lesquels Python, Java, C, Caml, Fortran, Cobol, etc. Il n\u2019est cependant pas n\u00e9cessaire d\u2019apprendre ces langages les uns apr\u00e8s les autres, car ils sont tous plus ou moins organis\u00e9s autour des m\u00eames notions : affectation , s\u00e9quence , test , boucle , fonction , etc. Le langage principal qui sera utilis\u00e9 durant ces deux ann\u00e9es de sp\u00e9cialit\u00e9 NSI est le langage Python. Apprendre la programmation, ce n\u2019est pas seulement apprendre \u00e0 \u00e9crire un programme, c\u2019est aussi comprendre de quoi il est fait, comment il est fait et ce qu\u2019il fait. Un programme est essentiellement constitu\u00e9 d\u2019 expressions et d\u2019 instructions . Nous introduisons dans ce cours trois instructions fondamentales que sont l \u2019affectation de variables, le test et la boucle . L\u2019affectation de variables L\u2019essentiel du travail effectu\u00e9 par un programme d\u2019ordinateur consiste \u00e0 manipuler des donn\u00e9es organis\u00e9es comme un ensemble de variable. Une variable appara\u00eet dans un langage de programmation sous un nom de variable qui doit \u00eatre explicite. Pour l\u2019ordinateur ce nom est une r\u00e9f\u00e9rence d\u00e9signant une adresse m\u00e9moire, c\u2019est-\u00e0-dire un emplacement pr\u00e9cis dans la m\u00e9moire vive. Pour stocker une valuer dans une variable, on utilise une instruction appel\u00e9e affectation, not\u00e9e par le signe = . Par exemple, l'affectation x = y + 3 est compos\u00e9e d\u2019une variable x et d\u2019une expression y + 3 . Les op\u00e9rations Op\u00e9ration sur des r\u00e9els Op\u00e9rations bool\u00e9ennes + Addition - Soustraction * Multiplication / Division // Quotient de la division euclidienne % Reste de la division euclidienne ** Puissance Le r\u00e9sultat d\u2019une expression bool\u00e9enne en peut prendre que deux \u00e9tats, vrai ( True en python) ou faux ( False ) Affectations multiples On peut assigner une valeur \u00e0 plusieurs variables simultan\u00e9ment. Exemple : >>> x = y = 7 On peut aussi effectuer des affectations parall\u00e8les \u00e0 l\u2019aide d\u2019un seul op\u00e9rateur : >>> a, b = 4, 8.33 Les bonne pratique de nommage Un nom de variable est une s\u00e9quence de lettres (a \u2192 z , A \u2192 Z) et de chiffres (0 \u2192 9), qui doit toujours commencer par une lettre. Seules les lettres ordinaires sont autoris\u00e9es. Les lettres accentu\u00e9es, les c\u00e9dilles, les espaces, les caract\u00e8res sp\u00e9ciaux tels que $, #, @, etc. sont interdits, \u00e0 l\u2019exception du caract\u00e8re _ (soulign\u00e9). La casse est significative (les caract\u00e8res majuscules et minuscules sont distingu\u00e9s). Le nommage des variables doit \u00eatre le plus explicite possible afin de simplifier la compr\u00e9hension du programme Le nom d\u2019une variable commence toujours par une minuscule Vous ne pouvez pas utiliser comme nom de variables les 33 \u00ab mots r\u00e9serv\u00e9s \u00bb ci-dessous ( utilis\u00e9s par le langage lui-m\u00eame) : and as assert break class continue def del elif else except False finally for from global if import in is lambda None nonlocal not or pass raise return True try while with yield Le test Si nous voulons pouvoir \u00e9crire des applications v\u00e9ritablement utiles, il nous faut des technique permettant d\u2019aiguiller le d\u00e9roulement du programme dans diff\u00e9rentes directions, en fonction des circonstances rencontr\u00e9es. En Python, la syntaxe d\u2019une instruction conditionnelle est la suivante : if expression : Instruction1 Instruction2 Instruction3 else : Instruction4 Instruction5 Remarquez les points suivants : la ligne de test commence par if , et la condition est suivie d\u2019un deux points (indispensable, sinon Python arr\u00eatera le script avec une erreur de syntaxe). les instructions 1 , 2 et 3 sont celles qui seront ex\u00e9cut\u00e9es si la condition est vraie ( True ) Ces instructions doivent \u00eatre indent\u00e9es (d\u00e9cal\u00e9es vers la droite) du m\u00eame nombre de tabulation pour indiquer qu\u2019elles font partie du m\u00eame if . La partie else instruction4 instruction5 est facultative. Ces instructions seront ex\u00e9cut\u00e9es seulement si la condition qui suit le if est fausse ( False ) Le mot else doit \u00eatre suivi d\u2019un deux-points ; il doit \u00eatre align\u00e9 avec le if auquel il correspond. Lorsqu\u2019on veut encha\u00eener plusieurs tests, on peut utiliser l\u2019instruction elif , qui est la contraction de else if . Cette instruction doit \u00eatre align\u00e9e avec le if correspondant, et elle doit \u00eatre suivie d\u2019une condition, puis d\u2019un deux-points et apr\u00e8s d\u2019instructions indent\u00e9es, comme pour un if . Les instructions seront ex\u00e9cut\u00e9es si la condition qui suit le if est fausse, mais que la condition qui suit le elif est vraie. La boucle En programmation, on appelle boucle un syst\u00e8me d\u2019instructions qui permet de r\u00e9p\u00e9ter un certain nombre de fois (voire ind\u00e9finiment) toute une s\u00e9rie d\u2019op\u00e9rations. Python propose deux instructions particuli\u00e8res pour construire des boucles : l\u2019instruction for et l\u2019instruction while La boucle non born\u00e9e While Le mot while signifie \u00ab tant que \u00bb en anglais. Cette instruction r\u00e9p\u00e9te continuellement le bloc d\u2019instructions qui suit, tant que l\u2019expression est vraie. while expression : Instruction1 Instruction2 Instruction3 Instruction4 Instruction5 la boucle born\u00e9e for La syntaxe d\u2019une boucle for est la suivante : for i in range ( e , e \u2019 ) : Instruction1 Instruction2 Instruction3 Instruction4 i est une variable, e et e\u2019 sont des expressions et instruction1 , instructions2 sont des instructions, appel\u00e9e corps de cette boucle. C\u2019est lui qui va s\u2019ex\u00e9cuter autant de fois que pr\u00e9cis\u00e9 dans la boucle. Comme dans le cas des tests, le corps d\u2019une boucle doit \u00eatre indent\u00e9. Cette boucle a pour effet d\u2019ex\u00e9cuter le corps de boucle ( n - m ) fois, o\u00f9 m est la valeur de l\u2019expression e et n celle de l\u2019expression e\u2019 . Pour chaque tour de boucle la valeur de la variable i est successivement m , m+1 , ..., n\u22121 . Par exemple, ex\u00e9cuter la boucle : for i in range ( 1 , 11 ): print ( \"all\u00f4 \" , end = \"\" ) print ( \"t\u2019es o\u00f9 ?\" ) * a pour effet d\u2019afficher : all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 t'es o\u00f9 ? Choisir entre une boucle for et la boucle while Si on conna\u00eet \u00e0 l\u2019avance le nombre de r\u00e9p\u00e9titions \u00e0 effectuer, la boucle for est toute indiqu\u00e9e. \u00c0 l\u2019inverse, si la d\u00e9cision d\u2019arr\u00eater la boucle ne peut s\u2019exprimer que par un test, c\u2019est la boucle while qu\u2019il faut choisir.","title":"Les bases du langage Python"},{"location":"1_Langage%20et%20programmation/Base_python/#structures-de-base-dun-programme","text":"Format PDF Un programme est un texte qui d\u00e9crit un algorithme que l\u2019on souhaite faire ex\u00e9cuter par une machine. Ce texte est \u00e9crit dans un langage particulier, appel\u00e9 langage de programmation. Il existe plusieurs milliers de langages de programmation, parmi lesquels Python, Java, C, Caml, Fortran, Cobol, etc. Il n\u2019est cependant pas n\u00e9cessaire d\u2019apprendre ces langages les uns apr\u00e8s les autres, car ils sont tous plus ou moins organis\u00e9s autour des m\u00eames notions : affectation , s\u00e9quence , test , boucle , fonction , etc. Le langage principal qui sera utilis\u00e9 durant ces deux ann\u00e9es de sp\u00e9cialit\u00e9 NSI est le langage Python. Apprendre la programmation, ce n\u2019est pas seulement apprendre \u00e0 \u00e9crire un programme, c\u2019est aussi comprendre de quoi il est fait, comment il est fait et ce qu\u2019il fait. Un programme est essentiellement constitu\u00e9 d\u2019 expressions et d\u2019 instructions . Nous introduisons dans ce cours trois instructions fondamentales que sont l \u2019affectation de variables, le test et la boucle .","title":"Structures de base d\u2019un programme"},{"location":"1_Langage%20et%20programmation/Base_python/#laffectation-de-variables","text":"L\u2019essentiel du travail effectu\u00e9 par un programme d\u2019ordinateur consiste \u00e0 manipuler des donn\u00e9es organis\u00e9es comme un ensemble de variable. Une variable appara\u00eet dans un langage de programmation sous un nom de variable qui doit \u00eatre explicite. Pour l\u2019ordinateur ce nom est une r\u00e9f\u00e9rence d\u00e9signant une adresse m\u00e9moire, c\u2019est-\u00e0-dire un emplacement pr\u00e9cis dans la m\u00e9moire vive. Pour stocker une valuer dans une variable, on utilise une instruction appel\u00e9e affectation, not\u00e9e par le signe = . Par exemple, l'affectation x = y + 3 est compos\u00e9e d\u2019une variable x et d\u2019une expression y + 3 .","title":"L\u2019affectation de variables"},{"location":"1_Langage%20et%20programmation/Base_python/#les-operations","text":"Op\u00e9ration sur des r\u00e9els Op\u00e9rations bool\u00e9ennes + Addition - Soustraction * Multiplication / Division // Quotient de la division euclidienne % Reste de la division euclidienne ** Puissance Le r\u00e9sultat d\u2019une expression bool\u00e9enne en peut prendre que deux \u00e9tats, vrai ( True en python) ou faux ( False )","title":"Les op\u00e9rations"},{"location":"1_Langage%20et%20programmation/Base_python/#affectations-multiples","text":"On peut assigner une valeur \u00e0 plusieurs variables simultan\u00e9ment. Exemple : >>> x = y = 7 On peut aussi effectuer des affectations parall\u00e8les \u00e0 l\u2019aide d\u2019un seul op\u00e9rateur : >>> a, b = 4, 8.33","title":"Affectations multiples"},{"location":"1_Langage%20et%20programmation/Base_python/#les-bonne-pratique-de-nommage","text":"Un nom de variable est une s\u00e9quence de lettres (a \u2192 z , A \u2192 Z) et de chiffres (0 \u2192 9), qui doit toujours commencer par une lettre. Seules les lettres ordinaires sont autoris\u00e9es. Les lettres accentu\u00e9es, les c\u00e9dilles, les espaces, les caract\u00e8res sp\u00e9ciaux tels que $, #, @, etc. sont interdits, \u00e0 l\u2019exception du caract\u00e8re _ (soulign\u00e9). La casse est significative (les caract\u00e8res majuscules et minuscules sont distingu\u00e9s). Le nommage des variables doit \u00eatre le plus explicite possible afin de simplifier la compr\u00e9hension du programme Le nom d\u2019une variable commence toujours par une minuscule Vous ne pouvez pas utiliser comme nom de variables les 33 \u00ab mots r\u00e9serv\u00e9s \u00bb ci-dessous ( utilis\u00e9s par le langage lui-m\u00eame) : and as assert break class continue def del elif else except False finally for from global if import in is lambda None nonlocal not or pass raise return True try while with yield","title":"Les bonne pratique de nommage"},{"location":"1_Langage%20et%20programmation/Base_python/#le-test","text":"Si nous voulons pouvoir \u00e9crire des applications v\u00e9ritablement utiles, il nous faut des technique permettant d\u2019aiguiller le d\u00e9roulement du programme dans diff\u00e9rentes directions, en fonction des circonstances rencontr\u00e9es. En Python, la syntaxe d\u2019une instruction conditionnelle est la suivante : if expression : Instruction1 Instruction2 Instruction3 else : Instruction4 Instruction5 Remarquez les points suivants : la ligne de test commence par if , et la condition est suivie d\u2019un deux points (indispensable, sinon Python arr\u00eatera le script avec une erreur de syntaxe). les instructions 1 , 2 et 3 sont celles qui seront ex\u00e9cut\u00e9es si la condition est vraie ( True ) Ces instructions doivent \u00eatre indent\u00e9es (d\u00e9cal\u00e9es vers la droite) du m\u00eame nombre de tabulation pour indiquer qu\u2019elles font partie du m\u00eame if . La partie else instruction4 instruction5 est facultative. Ces instructions seront ex\u00e9cut\u00e9es seulement si la condition qui suit le if est fausse ( False ) Le mot else doit \u00eatre suivi d\u2019un deux-points ; il doit \u00eatre align\u00e9 avec le if auquel il correspond. Lorsqu\u2019on veut encha\u00eener plusieurs tests, on peut utiliser l\u2019instruction elif , qui est la contraction de else if . Cette instruction doit \u00eatre align\u00e9e avec le if correspondant, et elle doit \u00eatre suivie d\u2019une condition, puis d\u2019un deux-points et apr\u00e8s d\u2019instructions indent\u00e9es, comme pour un if . Les instructions seront ex\u00e9cut\u00e9es si la condition qui suit le if est fausse, mais que la condition qui suit le elif est vraie.","title":"Le test"},{"location":"1_Langage%20et%20programmation/Base_python/#la-boucle","text":"En programmation, on appelle boucle un syst\u00e8me d\u2019instructions qui permet de r\u00e9p\u00e9ter un certain nombre de fois (voire ind\u00e9finiment) toute une s\u00e9rie d\u2019op\u00e9rations. Python propose deux instructions particuli\u00e8res pour construire des boucles : l\u2019instruction for et l\u2019instruction while","title":"La boucle"},{"location":"1_Langage%20et%20programmation/Base_python/#la-boucle-non-bornee-while","text":"Le mot while signifie \u00ab tant que \u00bb en anglais. Cette instruction r\u00e9p\u00e9te continuellement le bloc d\u2019instructions qui suit, tant que l\u2019expression est vraie. while expression : Instruction1 Instruction2 Instruction3 Instruction4 Instruction5","title":"La boucle non born\u00e9e While"},{"location":"1_Langage%20et%20programmation/Base_python/#la-boucle-bornee-for","text":"La syntaxe d\u2019une boucle for est la suivante : for i in range ( e , e \u2019 ) : Instruction1 Instruction2 Instruction3 Instruction4 i est une variable, e et e\u2019 sont des expressions et instruction1 , instructions2 sont des instructions, appel\u00e9e corps de cette boucle. C\u2019est lui qui va s\u2019ex\u00e9cuter autant de fois que pr\u00e9cis\u00e9 dans la boucle. Comme dans le cas des tests, le corps d\u2019une boucle doit \u00eatre indent\u00e9. Cette boucle a pour effet d\u2019ex\u00e9cuter le corps de boucle ( n - m ) fois, o\u00f9 m est la valeur de l\u2019expression e et n celle de l\u2019expression e\u2019 . Pour chaque tour de boucle la valeur de la variable i est successivement m , m+1 , ..., n\u22121 . Par exemple, ex\u00e9cuter la boucle : for i in range ( 1 , 11 ): print ( \"all\u00f4 \" , end = \"\" ) print ( \"t\u2019es o\u00f9 ?\" ) * a pour effet d\u2019afficher : all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 t'es o\u00f9 ?","title":"la boucle born\u00e9e for"},{"location":"1_Langage%20et%20programmation/Base_python/#choisir-entre-une-boucle-for-et-la-boucle-while","text":"Si on conna\u00eet \u00e0 l\u2019avance le nombre de r\u00e9p\u00e9titions \u00e0 effectuer, la boucle for est toute indiqu\u00e9e. \u00c0 l\u2019inverse, si la d\u00e9cision d\u2019arr\u00eater la boucle ne peut s\u2019exprimer que par un test, c\u2019est la boucle while qu\u2019il faut choisir.","title":"Choisir entre une boucle for et la boucle while"},{"location":"1_Langage%20et%20programmation/Interactions_utilisateur/","text":"Les int\u00e9ractions utilisateur (entr\u00e9es/sorties) Format PDF Dans l\u2019ex\u00e9cution d\u2019un programme, il est fr\u00e9quent que l\u2019utilisateur ait besoin de saisir des informations. Les fonctions particuli\u00e8res print() et input() permettent d\u2019int\u00e9ragir avec l\u2019utilisateur. La fonction print() La fonction print() sert \u00e0 afficher du texte et/ou le contenu d\u2019une variable. >>> print ( 'Bienvenue au cours de NSI.' ) Bienvenue au cours de NSI . >>> prenom = 'Boris' >>> print ( 'Bonjour' , prenom , ', bienvenue au cours de NSI.' ) Bonjour Boris , bienvenue au cours de NSI . Remarques Pour afficher plusieurs donn\u00e9es avec la fonction print(), il suffit de les s\u00e9parer avec des virgules. La fonction print() effectue un retour \u00e0 la ligne apr\u00e8s l\u2019affichage du texte. Ce retour \u00e0 la ligne peut \u00eatre inhib\u00e9 avec le param\u00e8tre end='' . for i in range ( 3 ) : print ( i ) Affiche 0 1 2 for i in range ( 3 ) : print ( i , end = '' ) Affiche 012 La fonction input() La fonction input() permet des int\u00e9raction avec l\u2019utilisateur : elle va stopper l\u2019ex\u00e9cution du programme et attendre que l\u2019utilisateur saisisse une donn\u00e9e. Le programme reprend lorsque l\u2019utilisateur appuie sur la touche ENTREE . La fonction renvoie alors le texte saisi par l\u2019utilisateur. L\u2019instruction suivante aura pour effet d\u2019ouvrir une zone de saisie dans laquelle l\u2019utilisateur pourra entrer une valeur. Cette valeur sera affect\u00e9e \u00e0 la variable nom. nom = input ( 'Quel est votre nom ?' ) Remarque La valeur renvoy\u00e9e par la fonction input() est une cha\u00eene de caract\u00e8re (type str ). Pour obtenir un nombre entier, il faudra saisir : age = int ( input ( \u2018 'Quel est votre age ?' ))","title":"Les int\u00e9ractions avec l'utilisateur"},{"location":"1_Langage%20et%20programmation/Interactions_utilisateur/#les-interactions-utilisateur-entreessorties","text":"Format PDF Dans l\u2019ex\u00e9cution d\u2019un programme, il est fr\u00e9quent que l\u2019utilisateur ait besoin de saisir des informations. Les fonctions particuli\u00e8res print() et input() permettent d\u2019int\u00e9ragir avec l\u2019utilisateur.","title":"Les int\u00e9ractions utilisateur (entr\u00e9es/sorties)"},{"location":"1_Langage%20et%20programmation/Interactions_utilisateur/#la-fonction-print","text":"La fonction print() sert \u00e0 afficher du texte et/ou le contenu d\u2019une variable. >>> print ( 'Bienvenue au cours de NSI.' ) Bienvenue au cours de NSI . >>> prenom = 'Boris' >>> print ( 'Bonjour' , prenom , ', bienvenue au cours de NSI.' ) Bonjour Boris , bienvenue au cours de NSI . Remarques Pour afficher plusieurs donn\u00e9es avec la fonction print(), il suffit de les s\u00e9parer avec des virgules. La fonction print() effectue un retour \u00e0 la ligne apr\u00e8s l\u2019affichage du texte. Ce retour \u00e0 la ligne peut \u00eatre inhib\u00e9 avec le param\u00e8tre end='' . for i in range ( 3 ) : print ( i ) Affiche 0 1 2 for i in range ( 3 ) : print ( i , end = '' ) Affiche 012","title":"La fonction print()"},{"location":"1_Langage%20et%20programmation/Interactions_utilisateur/#la-fonction-input","text":"La fonction input() permet des int\u00e9raction avec l\u2019utilisateur : elle va stopper l\u2019ex\u00e9cution du programme et attendre que l\u2019utilisateur saisisse une donn\u00e9e. Le programme reprend lorsque l\u2019utilisateur appuie sur la touche ENTREE . La fonction renvoie alors le texte saisi par l\u2019utilisateur. L\u2019instruction suivante aura pour effet d\u2019ouvrir une zone de saisie dans laquelle l\u2019utilisateur pourra entrer une valeur. Cette valeur sera affect\u00e9e \u00e0 la variable nom. nom = input ( 'Quel est votre nom ?' ) Remarque La valeur renvoy\u00e9e par la fonction input() est une cha\u00eene de caract\u00e8re (type str ). Pour obtenir un nombre entier, il faudra saisir : age = int ( input ( \u2018 'Quel est votre age ?' ))","title":"La fonction input()"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/","text":"Les cha\u00eenes de caract\u00e8res dans Python Une cha\u00eene de caract\u00e8res est une structure de donn\u00e9es composites . Une cha\u00eene de caract\u00e8res est form\u00e9e de plusieurs valeurs simples que sont ses diff\u00e9rents caract\u00e8res. Cette structure de donn\u00e9es est d\u00eetes immutable, c\u2019est \u00e0 dire qu\u2019il n\u2019est pas possible de la modifier sur place (impossibilit\u00e9 de rajouter ou retirer des caract\u00e8res). Pour modifier une cha\u00eene existante, on en extrait les parties appropri\u00e9es, et on reconstitue une nouvelle cha\u00eene \u00e0 l\u2019aide de l\u2019op\u00e9ration de concat\u00e9nation. D\u00e9claration d\u2019une cha\u00eene de caract\u00e8res Sous Python, on d\u00e9clare une chaine de caract\u00e8res enbordant le texte de guillemets (simple ou double quote) >>> a = 'Ceci est une chaine de caracteres' >>> a 'Ceci est une chaine de caracteres' Acc\u00e8s aux caract\u00e8res d\u2019une cha\u00eene de caract\u00e8res Puisqu\u2019une cha\u00eene de caract\u00e8re est une don\u00e9ne composite, il est possible d\u2019acc\u00e9der \u00e0 chaque caract\u00e8re la composant par son indice. Cette m\u00e9thode d\u2019acc\u00e8s est similaire \u00e0 celle utilis\u00e9e dans la manipulation de listes. L\u2019indice (ou index) du caract\u00e8re de la cha\u00eene est d\u00e9fini entre crochets. >>> a = 'Ceci est une chaine de caracteres' >>> a [ 0 ] 'C' >>> a [ 6 ] 's' >>> a [ - 1 ] 's' Le balayage d\u2019une cha\u00eene de caract\u00e8re Le balayage d\u2019une cha\u00eene de caract\u00e8re consiste \u00e0 lire successivement l\u2019ensemble des caract\u00e8res qu\u2019elle contient afin d\u2019\u00e9ventuellement op\u00e9rer un traitement. Cette op\u00e9ration peut \u00eatre r\u00e9alis\u00e9 avec une boucle for ayant la liste \u00e0 balayer comme argument. Dans l\u2019exemple suivant, la variable i prendra successivement les valeurs contenues dans le tableau. La boucle for sera donc ex\u00e9cut\u00e9es 9 fois puisque la cha\u00eene a contient 9 caract\u00e8res. 1 2 3 a = 'Ceci est ' for i in a : print ( i , end = \u2019\u2019 ) Equivalent \u00e0 : 1 2 3 a = 'Ceci est ' for i in range ( len ( a )): print ( a [ i ], end = \u2019\u2019 ) Op\u00e9ration sur les cha\u00eenes de caract\u00e8res Concat\u00e9nation et duplication Les cha\u00eenes de caract\u00e8res supportent l\u2019op\u00e9rateur + de concat\u00e9nation, ainsi que l\u2019op\u00e9rateur * pour la duplication : >>> a = 'Ceci est une ' >>> b = 'chaine de caracteres' >>> a + b 'Ceci est une chaine de caracteres' >>> a * 2 'Ceci est une Ceci est une ' Longueur d\u2019une cha\u00eene de caract\u00e8res La fonction len() permet de conna\u00eetre la longueur d\u2019une cha\u00eene de carct\u00e8res, c\u2019est-\u00e0-dire le nombre de caract\u00e8res qu\u2019elle contient. >>> a = 'toi' >>> len ( a ) 3 Test de pr\u00e9sence d\u2019un caract\u00e8re La pr\u00e9sence d\u2019un caract\u00e8re peut \u00eatre test\u00e9e avec la commande in >>> a = 'Ceci est ' >>> 'C' in a True >>> 'E' in a False Les tranches (slicing) Comme pour les listes, il est possible d\u2019extraire une partie d\u2019une cha\u00eene de caract\u00e8res en utilisant un indi\u00e7age construit sur le mod\u00e8le [m:n+1] pour r\u00e9cup\u00e9rer tous les \u00e9l\u00e9ments, du \u00e9mi\u00e8me au \u00e9ni\u00e8me (de l\u2019\u00e9l\u00e9ment m inclus \u00e0 l\u2019\u00e9l\u00e9ment n+1 exclu). >>> a = 'Ceci est ' >>> a [ 2 : 4 ] 'ci' >>> a [: 3 ] 'Cec' >>> a [: - 4 ] 'Ceci ' Comparaison de chaines Pour comparer des cha\u00eenes de caract\u00e8res, on utilise les op\u00e9rateurs == et <= cette derni\u00e8re relation comparant deux cha\u00eenes pour l\u2019ordre alphab\u00e9tique. >>> a = 'Ceci est ' >>> b = 'Cebi est ' >>> a == b False >>> b < a True","title":"Les cha\u00eenes de caract\u00e8res"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#les-chaines-de-caracteres-dans-python","text":"Une cha\u00eene de caract\u00e8res est une structure de donn\u00e9es composites . Une cha\u00eene de caract\u00e8res est form\u00e9e de plusieurs valeurs simples que sont ses diff\u00e9rents caract\u00e8res. Cette structure de donn\u00e9es est d\u00eetes immutable, c\u2019est \u00e0 dire qu\u2019il n\u2019est pas possible de la modifier sur place (impossibilit\u00e9 de rajouter ou retirer des caract\u00e8res). Pour modifier une cha\u00eene existante, on en extrait les parties appropri\u00e9es, et on reconstitue une nouvelle cha\u00eene \u00e0 l\u2019aide de l\u2019op\u00e9ration de concat\u00e9nation.","title":"Les cha\u00eenes de caract\u00e8res dans Python"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#declaration-dune-chaine-de-caracteres","text":"Sous Python, on d\u00e9clare une chaine de caract\u00e8res enbordant le texte de guillemets (simple ou double quote) >>> a = 'Ceci est une chaine de caracteres' >>> a 'Ceci est une chaine de caracteres'","title":"D\u00e9claration d\u2019une cha\u00eene de caract\u00e8res"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#acces-aux-caracteres-dune-chaine-de-caracteres","text":"Puisqu\u2019une cha\u00eene de caract\u00e8re est une don\u00e9ne composite, il est possible d\u2019acc\u00e9der \u00e0 chaque caract\u00e8re la composant par son indice. Cette m\u00e9thode d\u2019acc\u00e8s est similaire \u00e0 celle utilis\u00e9e dans la manipulation de listes. L\u2019indice (ou index) du caract\u00e8re de la cha\u00eene est d\u00e9fini entre crochets. >>> a = 'Ceci est une chaine de caracteres' >>> a [ 0 ] 'C' >>> a [ 6 ] 's' >>> a [ - 1 ] 's'","title":"Acc\u00e8s aux caract\u00e8res d\u2019une cha\u00eene de caract\u00e8res"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#le-balayage-dune-chaine-de-caractere","text":"Le balayage d\u2019une cha\u00eene de caract\u00e8re consiste \u00e0 lire successivement l\u2019ensemble des caract\u00e8res qu\u2019elle contient afin d\u2019\u00e9ventuellement op\u00e9rer un traitement. Cette op\u00e9ration peut \u00eatre r\u00e9alis\u00e9 avec une boucle for ayant la liste \u00e0 balayer comme argument. Dans l\u2019exemple suivant, la variable i prendra successivement les valeurs contenues dans le tableau. La boucle for sera donc ex\u00e9cut\u00e9es 9 fois puisque la cha\u00eene a contient 9 caract\u00e8res. 1 2 3 a = 'Ceci est ' for i in a : print ( i , end = \u2019\u2019 ) Equivalent \u00e0 : 1 2 3 a = 'Ceci est ' for i in range ( len ( a )): print ( a [ i ], end = \u2019\u2019 )","title":"Le balayage d\u2019une cha\u00eene de caract\u00e8re"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#operation-sur-les-chaines-de-caracteres","text":"","title":"Op\u00e9ration sur les cha\u00eenes de caract\u00e8res"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#concatenation-et-duplication","text":"Les cha\u00eenes de caract\u00e8res supportent l\u2019op\u00e9rateur + de concat\u00e9nation, ainsi que l\u2019op\u00e9rateur * pour la duplication : >>> a = 'Ceci est une ' >>> b = 'chaine de caracteres' >>> a + b 'Ceci est une chaine de caracteres' >>> a * 2 'Ceci est une Ceci est une '","title":"Concat\u00e9nation et duplication"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#longueur-dune-chaine-de-caracteres","text":"La fonction len() permet de conna\u00eetre la longueur d\u2019une cha\u00eene de carct\u00e8res, c\u2019est-\u00e0-dire le nombre de caract\u00e8res qu\u2019elle contient. >>> a = 'toi' >>> len ( a ) 3","title":"Longueur d\u2019une cha\u00eene de caract\u00e8res"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#test-de-presence-dun-caractere","text":"La pr\u00e9sence d\u2019un caract\u00e8re peut \u00eatre test\u00e9e avec la commande in >>> a = 'Ceci est ' >>> 'C' in a True >>> 'E' in a False","title":"Test de pr\u00e9sence d\u2019un caract\u00e8re"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#les-tranches-slicing","text":"Comme pour les listes, il est possible d\u2019extraire une partie d\u2019une cha\u00eene de caract\u00e8res en utilisant un indi\u00e7age construit sur le mod\u00e8le [m:n+1] pour r\u00e9cup\u00e9rer tous les \u00e9l\u00e9ments, du \u00e9mi\u00e8me au \u00e9ni\u00e8me (de l\u2019\u00e9l\u00e9ment m inclus \u00e0 l\u2019\u00e9l\u00e9ment n+1 exclu). >>> a = 'Ceci est ' >>> a [ 2 : 4 ] 'ci' >>> a [: 3 ] 'Cec' >>> a [: - 4 ] 'Ceci '","title":"Les tranches (slicing)"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#comparaison-de-chaines","text":"Pour comparer des cha\u00eenes de caract\u00e8res, on utilise les op\u00e9rateurs == et <= cette derni\u00e8re relation comparant deux cha\u00eenes pour l\u2019ordre alphab\u00e9tique. >>> a = 'Ceci est ' >>> b = 'Cebi est ' >>> a == b False >>> b < a True","title":"Comparaison de chaines"},{"location":"1_Langage%20et%20programmation/fonctions/","text":"Les fonctions Format PDF Les fonctions sont des bouts de code d'un programme qui sont ex\u00e9cut\u00e9s \u00e0 chaque fois qu'ils sont appel\u00e9s. Elles permettent de structurer le code, d\u2019\u00e9viter les redondances, de le rendre plus lisible dans le but d\u2019en faciliter la maintenance. L\u2019utilisation de fonctions fait partie des bonnes pratiques de la programmation. D\u00e9finition d\u2019une fonction def nom_fonction ( argument1 , argument2 , ... ) : # Code de la fonction return valeur de retour # Code hors fonction Appel d\u2019une fonction Consid\u00e9rons une fonction double qui multiplie par 2 la somme de deux nombres pass\u00e9s en param\u00e8tre. Une telle fonction s\u2019\u00e9crira : def double ( a , b ) : resultat = 2 * ( a + b ) return resultat L\u2019appel suivant de la fonction renvoie donc la valeur 24 (2*(4+8) = 24) >>> double(4,8) 24 Sp\u00e9cification d\u2019une fonction Une fonction prend des arguments en param\u00e8tre, les manipule et renvoie un r\u00e9sultat. Cette organisation d\u2019un programme permet la r\u00e9utilisation et le partage d\u2019algorithmes plus ou moins complexes. Cette notion de partage oblige les concepteurs de fonctions \u00e0 d\u00e9crire la fonction afin de sp\u00e9cifier : Le nom de l\u2019algorithme, La description des param\u00e8tres : quelles variables, quels types ... La description du r\u00e9sultat Cette sp\u00e9cification est r\u00e9alis\u00e9e au d\u00e9but de la fonction par l\u2019utilisation de docstrings . def puissance ( n , p ) : \"\"\" Calcul la puissance de p du nombre n arguments : n nombre reel* p nombre reel* retour : renvoie le resultat de n puissance p* \"\"\" return n ** p Remarque : Les docstrings sont cr\u00e9\u00e9s en apposant trois simples cotes au d\u00e9but du commentaires et trois autres d\u00e9cal\u00e9s d\u2019une tabulation. Port\u00e9e des variables Les variables locales Les variables d\u00e9finies \u00e0 l\u2019int\u00e9rieur de la fonction ont une port\u00e9e locale c\u2019est \u00e0 dire qu\u2019elles sont cr\u00e9\u00e9es \u00e0 l\u2019appel de la fonction et d\u00e9truites \u00e0 la sortie de la fonction. def ajoute_1 ( x ) : resultat = x + 1 return resultat Ici resultat, est une variable locale \u00e0 la fonction. Celle-ci n\u2019existe qu\u2019au sein de la fonction ajoute_1 et n\u2019est pas visible par le programme principal. Variable globale Par opposition aux variables locales, une variable globale est une variable cr\u00e9\u00e9e dans le programme principal (hors de toute fonction). Une variable globale est accessible partout : dans les fonctions et dans le programme principal. Par exemple, ce programme affiche la valeur 84 def double () : return 2 * v v = 42 w = double () print ( w ) On recommande cependant de ne pas d\u00e9finir de fonctions dont le code d\u00e9pend de variables globales dont la valeur peut changer. A l\u2019inverse, il est tout \u00e0 fait l\u00e9gitime d\u2019utiliser des variables globales pour stocker des constantes utilis\u00e9es dans des fonctions. Erreurs fr\u00e9quentes lors de la programmation de fonctions La d\u00e9finition de la fonction se termine par : La fonction doit \u00eatre document\u00e9e par l\u2019utilisation de docstrings. Cette documentation est indent\u00e9e par rapport \u00e0 la d\u00e9finition de la fonction. Le corps de la fonction doit \u00eatre indent\u00e9 Les variables locales ne doivent pas \u00eatre appel\u00e9es \u00e0 l\u2019ext\u00e9rieur de la fonction L\u2019instruction print n\u2019\u00e9quivaut pas \u00e0 un return. En effet print permet d\u2019afficher un r\u00e9sultat dans la console alors que return permet de sortir de la fonction et de renvoyer un r\u00e9sultat si besoin.","title":"Les fonctions"},{"location":"1_Langage%20et%20programmation/fonctions/#les-fonctions","text":"Format PDF Les fonctions sont des bouts de code d'un programme qui sont ex\u00e9cut\u00e9s \u00e0 chaque fois qu'ils sont appel\u00e9s. Elles permettent de structurer le code, d\u2019\u00e9viter les redondances, de le rendre plus lisible dans le but d\u2019en faciliter la maintenance. L\u2019utilisation de fonctions fait partie des bonnes pratiques de la programmation.","title":"Les fonctions"},{"location":"1_Langage%20et%20programmation/fonctions/#definition-dune-fonction","text":"def nom_fonction ( argument1 , argument2 , ... ) : # Code de la fonction return valeur de retour # Code hors fonction","title":"D\u00e9finition d\u2019une fonction"},{"location":"1_Langage%20et%20programmation/fonctions/#appel-dune-fonction","text":"Consid\u00e9rons une fonction double qui multiplie par 2 la somme de deux nombres pass\u00e9s en param\u00e8tre. Une telle fonction s\u2019\u00e9crira : def double ( a , b ) : resultat = 2 * ( a + b ) return resultat L\u2019appel suivant de la fonction renvoie donc la valeur 24 (2*(4+8) = 24) >>> double(4,8) 24","title":"Appel d\u2019une fonction"},{"location":"1_Langage%20et%20programmation/fonctions/#specification-dune-fonction","text":"Une fonction prend des arguments en param\u00e8tre, les manipule et renvoie un r\u00e9sultat. Cette organisation d\u2019un programme permet la r\u00e9utilisation et le partage d\u2019algorithmes plus ou moins complexes. Cette notion de partage oblige les concepteurs de fonctions \u00e0 d\u00e9crire la fonction afin de sp\u00e9cifier : Le nom de l\u2019algorithme, La description des param\u00e8tres : quelles variables, quels types ... La description du r\u00e9sultat Cette sp\u00e9cification est r\u00e9alis\u00e9e au d\u00e9but de la fonction par l\u2019utilisation de docstrings . def puissance ( n , p ) : \"\"\" Calcul la puissance de p du nombre n arguments : n nombre reel* p nombre reel* retour : renvoie le resultat de n puissance p* \"\"\" return n ** p Remarque : Les docstrings sont cr\u00e9\u00e9s en apposant trois simples cotes au d\u00e9but du commentaires et trois autres d\u00e9cal\u00e9s d\u2019une tabulation.","title":"Sp\u00e9cification d\u2019une fonction"},{"location":"1_Langage%20et%20programmation/fonctions/#portee-des-variables","text":"","title":"Port\u00e9e des variables"},{"location":"1_Langage%20et%20programmation/fonctions/#les-variables-locales","text":"Les variables d\u00e9finies \u00e0 l\u2019int\u00e9rieur de la fonction ont une port\u00e9e locale c\u2019est \u00e0 dire qu\u2019elles sont cr\u00e9\u00e9es \u00e0 l\u2019appel de la fonction et d\u00e9truites \u00e0 la sortie de la fonction. def ajoute_1 ( x ) : resultat = x + 1 return resultat Ici resultat, est une variable locale \u00e0 la fonction. Celle-ci n\u2019existe qu\u2019au sein de la fonction ajoute_1 et n\u2019est pas visible par le programme principal.","title":"Les variables locales"},{"location":"1_Langage%20et%20programmation/fonctions/#variable-globale","text":"Par opposition aux variables locales, une variable globale est une variable cr\u00e9\u00e9e dans le programme principal (hors de toute fonction). Une variable globale est accessible partout : dans les fonctions et dans le programme principal. Par exemple, ce programme affiche la valeur 84 def double () : return 2 * v v = 42 w = double () print ( w ) On recommande cependant de ne pas d\u00e9finir de fonctions dont le code d\u00e9pend de variables globales dont la valeur peut changer. A l\u2019inverse, il est tout \u00e0 fait l\u00e9gitime d\u2019utiliser des variables globales pour stocker des constantes utilis\u00e9es dans des fonctions.","title":"Variable globale"},{"location":"1_Langage%20et%20programmation/fonctions/#erreurs-frequentes-lors-de-la-programmation-de-fonctions","text":"La d\u00e9finition de la fonction se termine par : La fonction doit \u00eatre document\u00e9e par l\u2019utilisation de docstrings. Cette documentation est indent\u00e9e par rapport \u00e0 la d\u00e9finition de la fonction. Le corps de la fonction doit \u00eatre indent\u00e9 Les variables locales ne doivent pas \u00eatre appel\u00e9es \u00e0 l\u2019ext\u00e9rieur de la fonction L\u2019instruction print n\u2019\u00e9quivaut pas \u00e0 un return. En effet print permet d\u2019afficher un r\u00e9sultat dans la console alors que return permet de sortir de la fonction et de renvoyer un r\u00e9sultat si besoin.","title":"Erreurs fr\u00e9quentes lors de la programmation de fonctions"},{"location":"1_Langage%20et%20programmation/listes/Construction_listes/","text":"Construction de listes D\u00e9claration d\u2019une liste (rappel) Sous Python, on peut costruire une liste comme une collection d\u2019\u00e9l\u00e9ments s\u00e9par\u00e9s par des virgules, l\u2019ensemble \u00e9tant enferm\u00e9 dans des crochets. Exemple : >>> a = [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] >>> a [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] 0 La premi\u00e8re instruction cr\u00e9e une variable a dont le contenu fait r\u00e9f\u00e9rence \u00e0 une liste de 10 entiers. Construction de grandes listes Si on doit construire une liste vraiment grande, il devient difficile de le faire en \u00e9num\u00e9rant tous ses \u00e9l\u00e9ments. Diff\u00e9rentes mani\u00e8res d\u2019initailaiser la liste peuvent alors \u00eatre utilis\u00e9es. Construction d\u2019une liste avec une valeure unique. On peut utiliser l\u2019op\u00e9rateur * pour indiquer la longueur de la liste : >>> a = [ 0 ] * 1000 >>> len ( a ) 1000 >>> a [ 0 ] 0 >>> a [ - 1 ] 0 Listes par compr\u00e9hension La liste en compr\u00e9hension permet d'\u00e9crire des boucles for plus concises. Tr\u00e8s utiles d\u00e8s lors que l\u2019on souhaite cr\u00e9er une nouvelle liste bas\u00e9e sur une pr\u00e9-existante. Par exemple, on peut utiliser une liste en compr\u00e9hension pour cr\u00e9er une liste contenant les carr\u00e9s des 1000 premiers entiers. Classiquement ce programme peut s\u2019\u00e9crire : a = [ 0 ] * 1000 for i in range ( 1000 ) : a [ i ] = i * i Python propose une syntaxe simplifi\u00e9e pour combiner l\u2019allocation de la liste et son remplissage par la notation suivante : >>> a = [ i * i for i in range ( 1000 )] >>> a [ 0 , 1 , 4 , 9 , 16 , \u2026 , 996004 , 9988001 ] Cette nouvelle construction m\u00e9lange les crochets, qui explicitent la construction d\u2019une liste, et les mots-cl\u00e9s de la boucle for de Python, qui explicite le remplissage de la liste avec une boucle. Cette structure s\u2019appelle une liste par compr\u00e9hension. Dans cette construction, le parcours de la variable i n\u2019est pas limit\u00e9e \u00e0 un intervalle d\u2019entiers construits avec range. On peut parcourir une autre liste : >>> t = [ 3 * i + 1 for i in range ( 10 )] >>> a = [ x * x for x in t ] >>> t [ 1 , 4 , 7 , 10 , 13 , 16 , 19 , 22 , 25 , 28 ] >>> a [ 1 , 16 , 49 , 100 , 169 , 256 , 361 , 484 , 625 , 784 ] Il est possible de ne conserver que certaines valeurs prises par la variable, en ajoutant une condition bool\u00e9enne \u00e0 la compr\u00e9hension, avec le mot-cl\u00e9 if >>> a = [ i * i for i in range ( 30 ) if i % 4 == 1 ] >>> a [ 1 , 25 , 81 , 169 , 289 , 441 , 625 , 841 ]","title":"Construction de listes"},{"location":"1_Langage%20et%20programmation/listes/Construction_listes/#construction-de-listes","text":"","title":"Construction de listes"},{"location":"1_Langage%20et%20programmation/listes/Construction_listes/#declaration-dune-liste-rappel","text":"Sous Python, on peut costruire une liste comme une collection d\u2019\u00e9l\u00e9ments s\u00e9par\u00e9s par des virgules, l\u2019ensemble \u00e9tant enferm\u00e9 dans des crochets. Exemple : >>> a = [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] >>> a [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] 0 La premi\u00e8re instruction cr\u00e9e une variable a dont le contenu fait r\u00e9f\u00e9rence \u00e0 une liste de 10 entiers.","title":"D\u00e9claration d\u2019une liste (rappel)"},{"location":"1_Langage%20et%20programmation/listes/Construction_listes/#construction-de-grandes-listes","text":"Si on doit construire une liste vraiment grande, il devient difficile de le faire en \u00e9num\u00e9rant tous ses \u00e9l\u00e9ments. Diff\u00e9rentes mani\u00e8res d\u2019initailaiser la liste peuvent alors \u00eatre utilis\u00e9es.","title":"Construction de grandes listes"},{"location":"1_Langage%20et%20programmation/listes/Construction_listes/#construction-dune-liste-avec-une-valeure-unique","text":"On peut utiliser l\u2019op\u00e9rateur * pour indiquer la longueur de la liste : >>> a = [ 0 ] * 1000 >>> len ( a ) 1000 >>> a [ 0 ] 0 >>> a [ - 1 ] 0","title":"Construction d\u2019une liste avec une valeure unique."},{"location":"1_Langage%20et%20programmation/listes/Construction_listes/#listes-par-comprehension","text":"La liste en compr\u00e9hension permet d'\u00e9crire des boucles for plus concises. Tr\u00e8s utiles d\u00e8s lors que l\u2019on souhaite cr\u00e9er une nouvelle liste bas\u00e9e sur une pr\u00e9-existante. Par exemple, on peut utiliser une liste en compr\u00e9hension pour cr\u00e9er une liste contenant les carr\u00e9s des 1000 premiers entiers. Classiquement ce programme peut s\u2019\u00e9crire : a = [ 0 ] * 1000 for i in range ( 1000 ) : a [ i ] = i * i Python propose une syntaxe simplifi\u00e9e pour combiner l\u2019allocation de la liste et son remplissage par la notation suivante : >>> a = [ i * i for i in range ( 1000 )] >>> a [ 0 , 1 , 4 , 9 , 16 , \u2026 , 996004 , 9988001 ] Cette nouvelle construction m\u00e9lange les crochets, qui explicitent la construction d\u2019une liste, et les mots-cl\u00e9s de la boucle for de Python, qui explicite le remplissage de la liste avec une boucle. Cette structure s\u2019appelle une liste par compr\u00e9hension. Dans cette construction, le parcours de la variable i n\u2019est pas limit\u00e9e \u00e0 un intervalle d\u2019entiers construits avec range. On peut parcourir une autre liste : >>> t = [ 3 * i + 1 for i in range ( 10 )] >>> a = [ x * x for x in t ] >>> t [ 1 , 4 , 7 , 10 , 13 , 16 , 19 , 22 , 25 , 28 ] >>> a [ 1 , 16 , 49 , 100 , 169 , 256 , 361 , 484 , 625 , 784 ] Il est possible de ne conserver que certaines valeurs prises par la variable, en ajoutant une condition bool\u00e9enne \u00e0 la compr\u00e9hension, avec le mot-cl\u00e9 if >>> a = [ i * i for i in range ( 30 ) if i % 4 == 1 ] >>> a [ 1 , 25 , 81 , 169 , 289 , 441 , 625 , 841 ]","title":"Listes par compr\u00e9hension"},{"location":"1_Langage%20et%20programmation/listes/listes/","text":"Les listes Dans de nombreuses situations, on a besoin d\u2019utiliser des valeurs qui, comme les textes, les images ou les sons, sont form\u00e9es de plusieurs nombres ou de plusieurs bool\u00e9ens. Ces valeurs sont dites des donn\u00e9es composites. . Sous python le nom de liste est utilis\u00e9. D\u00e9claration d\u2019une liste Sous Python, on peut d\u00e9finir une liste comme une collection d\u2019\u00e9l\u00e9ments s\u00e9par\u00e9s par des virgules, l\u2019ensemble \u00e9tant enferm\u00e9 dans des crochets. Exemple Structure d'une liste >>> a = [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] >>> a [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] La premi\u00e8re instruction cr\u00e9e une variable a dont le contenu fait r\u00e9f\u00e9rence \u00e0 une liste de 10 entiers. Acc\u00e8s aux donn\u00e9es d\u2019une liste Un des gros avantages d\u2019une liste est que l\u2019on peut appeler ses \u00e9l\u00e9ments par leur position. Ce num\u00e9ro est appel\u00e9 indice (ou index) de la liste. On acc\u00e8de \u00e0 une case d\u2019une liste avec l\u2019expression NomVariable[index] . nomVariable correspond au nom de la bo\u00eete, dont le contenu est la r\u00e9f\u00e9rence \u00e0 la liste \u00e0 n cases et index est une expression dont la valeur est un nombre entier compris entre 0 et n \u2013 1 . Index d\u2019une liste La num\u00e9rotation des indexs d\u2019une liste de n \u00e9l\u00e9ments commence \u00e0 partir de z\u00e9ro et se termine \u00e0 n-1. Mais la liste peut \u00e9galement \u00eatre index\u00e9e avec des nombres n\u00e9gatifs. Les indices n\u00e9gatifs reviennent \u00e0 compter \u00e0 partir de la fin. Leur principal avantage estest de pouvoir acc\u00e9der au dernier \u00e9l\u00e9ment d\u2019une liste \u00e0 l\u2019aide de l\u2019indice -1 sans pour autant conna\u00eetre la longueur de cette liste. L\u2019avant dernier \u00e9l\u00e9ment a lui l\u2019indice -2 , l\u2019avant-avant dernier l\u2019indice -3 , etc. Indices d'un tableau >>> a = [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] >>> a [ 0 ] 1 >>> a [ 6 ] 785 >>> a [ - 1 ] 87 Les tranches (slicing) Un autre avantage des listes est la possibilit\u00e9 de s\u00e9lectionner une partie d\u2019une liste en utilisant un indi\u00e7age construit sur le mod\u00e8le [m : n+1] pour r\u00e9cup\u00e9rer tous les \u00e9l\u00e9ments, du \u00e9mi\u00e8me au \u00e9ni\u00e8me (de l\u2019\u00e9l\u00e9ment m inclus \u00e0 l\u2019\u00e9l\u00e9ment n+1 exclu). On dit alors qu\u2019on r\u00e9cup\u00e8re une tranche de la liste, par exemple : >>> a = [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] >>> a [ 2 : 4 ] [ 2 , 3 ] >>> a [: 3 ] [ 1 , 10 , 2 ] >>> a [: - 4 ] [ 1 , 10 , 2 , 3 , 56 , 89 ] Op\u00e9ration sur les listes Le balayage d\u2019une liste Le balyage d\u2019une liste consiste \u00e0 lire successivement l\u2019ensemble des valeurs contenues dans une liste afin d\u2019\u00e9ventuellement op\u00e9rer un traitement. Cette op\u00e9ration peut \u00eatre r\u00e9alis\u00e9 avec une boucle for ayant la liste \u00e0 balayer comme argument. Dans l\u2019exemple suivant, la variable i prendra successivement les valeurs contenues dans le tableau. La boucle for sera donc ex\u00e9cut\u00e9es 4 fois puisque la liste a contient 4 \u00e9l\u00e9ments.","title":"Les listes"},{"location":"1_Langage%20et%20programmation/listes/listes/#les-listes","text":"Dans de nombreuses situations, on a besoin d\u2019utiliser des valeurs qui, comme les textes, les images ou les sons, sont form\u00e9es de plusieurs nombres ou de plusieurs bool\u00e9ens. Ces valeurs sont dites des donn\u00e9es composites. . Sous python le nom de liste est utilis\u00e9.","title":"Les listes"},{"location":"1_Langage%20et%20programmation/listes/listes/#declaration-dune-liste","text":"Sous Python, on peut d\u00e9finir une liste comme une collection d\u2019\u00e9l\u00e9ments s\u00e9par\u00e9s par des virgules, l\u2019ensemble \u00e9tant enferm\u00e9 dans des crochets. Exemple Structure d'une liste >>> a = [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] >>> a [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] La premi\u00e8re instruction cr\u00e9e une variable a dont le contenu fait r\u00e9f\u00e9rence \u00e0 une liste de 10 entiers.","title":"D\u00e9claration d\u2019une liste"},{"location":"1_Langage%20et%20programmation/listes/listes/#acces-aux-donnees-dune-liste","text":"Un des gros avantages d\u2019une liste est que l\u2019on peut appeler ses \u00e9l\u00e9ments par leur position. Ce num\u00e9ro est appel\u00e9 indice (ou index) de la liste. On acc\u00e8de \u00e0 une case d\u2019une liste avec l\u2019expression NomVariable[index] . nomVariable correspond au nom de la bo\u00eete, dont le contenu est la r\u00e9f\u00e9rence \u00e0 la liste \u00e0 n cases et index est une expression dont la valeur est un nombre entier compris entre 0 et n \u2013 1 .","title":"Acc\u00e8s aux donn\u00e9es d\u2019une liste"},{"location":"1_Langage%20et%20programmation/listes/listes/#index-dune-liste","text":"La num\u00e9rotation des indexs d\u2019une liste de n \u00e9l\u00e9ments commence \u00e0 partir de z\u00e9ro et se termine \u00e0 n-1. Mais la liste peut \u00e9galement \u00eatre index\u00e9e avec des nombres n\u00e9gatifs. Les indices n\u00e9gatifs reviennent \u00e0 compter \u00e0 partir de la fin. Leur principal avantage estest de pouvoir acc\u00e9der au dernier \u00e9l\u00e9ment d\u2019une liste \u00e0 l\u2019aide de l\u2019indice -1 sans pour autant conna\u00eetre la longueur de cette liste. L\u2019avant dernier \u00e9l\u00e9ment a lui l\u2019indice -2 , l\u2019avant-avant dernier l\u2019indice -3 , etc. Indices d'un tableau >>> a = [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] >>> a [ 0 ] 1 >>> a [ 6 ] 785 >>> a [ - 1 ] 87","title":"Index d\u2019une liste"},{"location":"1_Langage%20et%20programmation/listes/listes/#les-tranches-slicing","text":"Un autre avantage des listes est la possibilit\u00e9 de s\u00e9lectionner une partie d\u2019une liste en utilisant un indi\u00e7age construit sur le mod\u00e8le [m : n+1] pour r\u00e9cup\u00e9rer tous les \u00e9l\u00e9ments, du \u00e9mi\u00e8me au \u00e9ni\u00e8me (de l\u2019\u00e9l\u00e9ment m inclus \u00e0 l\u2019\u00e9l\u00e9ment n+1 exclu). On dit alors qu\u2019on r\u00e9cup\u00e8re une tranche de la liste, par exemple : >>> a = [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] >>> a [ 2 : 4 ] [ 2 , 3 ] >>> a [: 3 ] [ 1 , 10 , 2 ] >>> a [: - 4 ] [ 1 , 10 , 2 , 3 , 56 , 89 ]","title":"Les tranches (slicing)"},{"location":"1_Langage%20et%20programmation/listes/listes/#operation-sur-les-listes","text":"","title":"Op\u00e9ration sur les listes"},{"location":"1_Langage%20et%20programmation/listes/listes/#le-balayage-dune-liste","text":"Le balyage d\u2019une liste consiste \u00e0 lire successivement l\u2019ensemble des valeurs contenues dans une liste afin d\u2019\u00e9ventuellement op\u00e9rer un traitement. Cette op\u00e9ration peut \u00eatre r\u00e9alis\u00e9 avec une boucle for ayant la liste \u00e0 balayer comme argument. Dans l\u2019exemple suivant, la variable i prendra successivement les valeurs contenues dans le tableau. La boucle for sera donc ex\u00e9cut\u00e9es 4 fois puisque la liste a contient 4 \u00e9l\u00e9ments.","title":"Le balayage d\u2019une liste"},{"location":"2_Representation_information/entiers_positifs/","text":"Repr\u00e9sentation des nombres entiers positifs Format PDF Les repr\u00e9sentations \u00e9crites d\u2019un nombre sont multiples ; elles varient selon les cultures. On distingue principalement deux types d\u2019\u00e9critures : Ecriture \u00e0 base de symboles Le principe repose sur l\u2019addition (et parfois soustraction) de symboles repr\u00e9sentant des nombres. Par exemple : \u2022 La num\u00e9ration m\u00e9sopotamienne, 3000 ans av J.C. \u2022 La num\u00e9ration romaine \u2192 MMXIX = 2019 Ecriture \u00e0 base de rang (ou de position). Ce principe d\u2019\u00e9criture est utilis\u00e9 actuellement tous les jours 2019 = 2 x 1000 + 0 x 100 + 1 x 10 + 9 x 1. Ou encore : 2019 est \u00e9gal \u00e0 2 milliers, 0 centaines, 1 dizaine, 9 unit\u00e9s. Actuellement dans la vie quotidienne, la base 10 (d\u00e9cimale) est utilis\u00e9e (nous avons 10 doigts) alors que dans les ordinateurs repr\u00e9sentent les nombres selon la base 2 (les composants de bases utilis\u00e9s peuvent prendre deux \u00e9tats). Les nombres en base 2 sont repr\u00e9sent\u00e9s avec beaucoup de caract\u00e8res (32 caract\u00e8res et plus) ce qui rend fastidieux leur \u00e9criture. En cons\u00e9quence lors de l\u2019\u00e9tude de syst\u00e8mes informatiques, l\u2019utilisation de la base 16 (hexad\u00e9cimal) est privil\u00e9gi\u00e9e pour simplifier l\u2019\u00e9criture. Concept d\u2019une repr\u00e9sentation num\u00e9rique par base Les nombres que nous utilisons sont compos\u00e9s de chiffres c pond\u00e9r\u00e9s dans une base b. Dans une base b, il existe b-1 chiffres repr\u00e9sent\u00e9s par des symboles distincts. On peut donc g\u00e9n\u00e9raliser la forme d\u2019\u00e9criture d\u2019un nombre ainsi : La base d\u00e9cimales (base 10) Ce syst\u00e8me de num\u00e9ration, utilise dans la vie quotidienne, dispose de 10 symboles diff\u00e9rents : 0, 1, 2, 3, 4, 5, 6, 7, 8 et 9 . On parle de base 10. Un nombre entier positif N s\u2019\u00e9crit en base 10 : \\[ N_{10} = N = c_{n\u22121} \\times 10^{n\u22121} + c_{n\u22122} \\times 10^{n\u22122} + ... + c_{1} \\times 10^{1} + c_{0} \\times 10^{0} \\] Pour sp\u00e9cifier la base utilis\u00e9e, on place g\u00e9n\u00e9ralement le nombre entier positif suivi de la base utilis\u00e9e en indice. Exemple : \\[ 7 239_{10} = 7 239 = 7 \\times 10^3 + 2 \\times 10^2 + 3 \\times 10^1 + 9 \\ times 10^0 \\] Pour la base 10, on oublie souvent de sp\u00e9cifier la base car il s'agit de la base de num\u00e9ration utilis\u00e9e quotidiennement. Les digits correspondent aux coefficients cn. Ils ne peuvent prendre que des valeurs appartenant \u00e0 la base. Les poids sont les puissances de 10. Le poids est \u00e9gal \u00e0 la base \u00e9lev\u00e9e \u00e0 la puissance de son rang. Num\u00e9ration binaire (base 2) La num\u00e9ration binaire ou en base 2 utilise deux symboles : 0 et 1 . Cette base est tr\u00e8s commode pour distinguer les deux \u00e9tats logiques fondamentaux (Lampe allum\u00e9e ou \u00e9teinte, pr\u00e9sence ou non dans une pi\u00e8ce, couleur noir ou blanc...), et est tr\u00e8s utilis\u00e9e en informatique. On \u00e9crit : \\[ N = c_{n\u22121} \\times 2^{n\u22121} + c_{n\u22122} \\times 2^{n\u22122} + ... + c_{1} \\times 2^{1} + c_{0} \\times 2^{0} \\] Exemple : Que repr\u00e9sente la valeur 10000101\u2082 ? \\(10000101_2 = 1 \\times 2^7 + 0 \\times 2^6 + 0 \\times 2^5 + 0 \\times 2^4 + 0\\times 2^3 + 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0\\) ce qui vaut 133 En num\u00e9ration binaire, les digits ( \\(c_i\\) ) sont appel\u00e9s bit (abreviation de Binary digIT). Un code binaire \u00e0 n bits distingue \\(2^n\\) \u00e9tats ou combinaisons et la valeur la plus grande repr\u00e9sentable vaut \\(2^{n-1}\\) Le bit de poids le plus fort ( \\(c_{n-1}\\) ) est appel\u00e9 MSB (Most Significant Bit). Le bit de poids le plus faible ( \\(c_0\\) ) est appel\u00e9 LSB (Low Significant Bit). Un regroupement successif de 4 bits s'appelle un quartet . Un regroupement successif de 8 bits s'appelle un octet . Un regroupement successif de k bits (k > 8) s'appelle un mot de k bits. Num\u00e9ration hexad\u00e9cimale (base 16) Ce syst\u00e8me de num\u00e9ration est tr\u00e8s utilis\u00e9 dans l\u2019analyse du fonctionnement de syst\u00e8mes ordinateurs et micro-ordinateurs ainsi que dans le domaine des transmissions de donn\u00e9es. Cette base correspond \u00e0 une contraction d\u2019\u00e9criture de la base 2. Il comporte 16 symboles : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F . Pour indiquer la base 16, on peut utiliser le caract\u00e8re $ (dollar) devant le nombre, ou alors 16# devant le nombre. Exemple : \\(A8_{16}\\) = 16#A8 = $A8 On \u00e9crit : \\[ N = c_{n\u22121} \\times 16^{n\u22121} + c_{n\u22122} \\times 16^{n\u22122} + ... + c_{1} \\times 16^{1} + c_{0} \\times 16^{0} \\] Exemple : Que repr\u00e9sente la valeur $A8 ? \\(A8_{16} =10 \\times 16^1 + 8 \\times 16^0\\) ce qui vaut 168 Les changements de base Conversions directes Du binaire vers l'hexad\u00e9cimal_ : Pour convertir du binaire vers l'hexad\u00e9cimal, on divise le nombre binaire en quartet, en partant de la droite. Chacun des paquets est ensuite converti en hexad\u00e9cimal. Exemple : 110101110001\u2082 = 1101 0111 0001\u2082 = 16#D71 De l'hexad\u00e9cimal vers le binaire : C'est le processus directement inverse, on \u00e9crit chaque quartet sur 4 bits en binaire en compl\u00e9tant \u00e9ventuellement avec des z\u00e9ros sur la gauche. Exemple : 1C3516 = 0001 1100 0011 0101\u2082 Conversions indirectes Un nombre entier positif N \u00e9tant donn\u00e9 en base 10, on cherche \u00e0 l'\u00e9crire dans une autre base not\u00e9e b. La m\u00e9thode consiste \u00e0 diviser le nombre d\u00e9cimal N par b et \u00e0 conserver le reste (division enti\u00e8re). Le quotient obtenu est ainsi successivement divis\u00e9 tant qu'il n'est pas nul. Les restes successifs sont \u00e9crits, en commen\u00e7ant par le dernier, de la gauche vers la droite, pour former l'expression de N dans le syst\u00e8me de base b. Du d\u00e9cimal vers le binaire Exemple pour la conversion de 173 en base 2, il faut effectuer des divisions successives par 2 Divisions successives par 2 le r\u00e9sultat est donc 17310 \u2192 10101101\u2082 Du d\u00e9cimal vers l'hexad\u00e9cimal : On reprend la m\u00eame m\u00e9thode mais en divisant par 16 : Divisions successives par 16 le r\u00e9sultat est donc 17310 \u2192 $AD. Remarque : La division euclidienne \u00e9tant source d\u2019erreur de calcul, il est conseill\u00e9 d\u2019effectuer la conversion en base 2 du nombre en base 10 puis de convertir le nombre binaire en base 16.","title":"Repr\u00e9sentation des entiers positifs"},{"location":"2_Representation_information/entiers_positifs/#representation-des-nombres-entiers-positifs","text":"Format PDF Les repr\u00e9sentations \u00e9crites d\u2019un nombre sont multiples ; elles varient selon les cultures. On distingue principalement deux types d\u2019\u00e9critures : Ecriture \u00e0 base de symboles Le principe repose sur l\u2019addition (et parfois soustraction) de symboles repr\u00e9sentant des nombres. Par exemple : \u2022 La num\u00e9ration m\u00e9sopotamienne, 3000 ans av J.C. \u2022 La num\u00e9ration romaine \u2192 MMXIX = 2019 Ecriture \u00e0 base de rang (ou de position). Ce principe d\u2019\u00e9criture est utilis\u00e9 actuellement tous les jours 2019 = 2 x 1000 + 0 x 100 + 1 x 10 + 9 x 1. Ou encore : 2019 est \u00e9gal \u00e0 2 milliers, 0 centaines, 1 dizaine, 9 unit\u00e9s. Actuellement dans la vie quotidienne, la base 10 (d\u00e9cimale) est utilis\u00e9e (nous avons 10 doigts) alors que dans les ordinateurs repr\u00e9sentent les nombres selon la base 2 (les composants de bases utilis\u00e9s peuvent prendre deux \u00e9tats). Les nombres en base 2 sont repr\u00e9sent\u00e9s avec beaucoup de caract\u00e8res (32 caract\u00e8res et plus) ce qui rend fastidieux leur \u00e9criture. En cons\u00e9quence lors de l\u2019\u00e9tude de syst\u00e8mes informatiques, l\u2019utilisation de la base 16 (hexad\u00e9cimal) est privil\u00e9gi\u00e9e pour simplifier l\u2019\u00e9criture.","title":"Repr\u00e9sentation des nombres entiers positifs"},{"location":"2_Representation_information/entiers_positifs/#concept-dune-representation-numerique-par-base","text":"Les nombres que nous utilisons sont compos\u00e9s de chiffres c pond\u00e9r\u00e9s dans une base b. Dans une base b, il existe b-1 chiffres repr\u00e9sent\u00e9s par des symboles distincts. On peut donc g\u00e9n\u00e9raliser la forme d\u2019\u00e9criture d\u2019un nombre ainsi :","title":"Concept d\u2019une repr\u00e9sentation num\u00e9rique par base"},{"location":"2_Representation_information/entiers_positifs/#la-base-decimales-base-10","text":"Ce syst\u00e8me de num\u00e9ration, utilise dans la vie quotidienne, dispose de 10 symboles diff\u00e9rents : 0, 1, 2, 3, 4, 5, 6, 7, 8 et 9 . On parle de base 10. Un nombre entier positif N s\u2019\u00e9crit en base 10 : \\[ N_{10} = N = c_{n\u22121} \\times 10^{n\u22121} + c_{n\u22122} \\times 10^{n\u22122} + ... + c_{1} \\times 10^{1} + c_{0} \\times 10^{0} \\] Pour sp\u00e9cifier la base utilis\u00e9e, on place g\u00e9n\u00e9ralement le nombre entier positif suivi de la base utilis\u00e9e en indice. Exemple : \\[ 7 239_{10} = 7 239 = 7 \\times 10^3 + 2 \\times 10^2 + 3 \\times 10^1 + 9 \\ times 10^0 \\] Pour la base 10, on oublie souvent de sp\u00e9cifier la base car il s'agit de la base de num\u00e9ration utilis\u00e9e quotidiennement. Les digits correspondent aux coefficients cn. Ils ne peuvent prendre que des valeurs appartenant \u00e0 la base. Les poids sont les puissances de 10. Le poids est \u00e9gal \u00e0 la base \u00e9lev\u00e9e \u00e0 la puissance de son rang.","title":"La base d\u00e9cimales (base 10)"},{"location":"2_Representation_information/entiers_positifs/#numeration-binaire-base-2","text":"La num\u00e9ration binaire ou en base 2 utilise deux symboles : 0 et 1 . Cette base est tr\u00e8s commode pour distinguer les deux \u00e9tats logiques fondamentaux (Lampe allum\u00e9e ou \u00e9teinte, pr\u00e9sence ou non dans une pi\u00e8ce, couleur noir ou blanc...), et est tr\u00e8s utilis\u00e9e en informatique. On \u00e9crit : \\[ N = c_{n\u22121} \\times 2^{n\u22121} + c_{n\u22122} \\times 2^{n\u22122} + ... + c_{1} \\times 2^{1} + c_{0} \\times 2^{0} \\] Exemple : Que repr\u00e9sente la valeur 10000101\u2082 ? \\(10000101_2 = 1 \\times 2^7 + 0 \\times 2^6 + 0 \\times 2^5 + 0 \\times 2^4 + 0\\times 2^3 + 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0\\) ce qui vaut 133 En num\u00e9ration binaire, les digits ( \\(c_i\\) ) sont appel\u00e9s bit (abreviation de Binary digIT). Un code binaire \u00e0 n bits distingue \\(2^n\\) \u00e9tats ou combinaisons et la valeur la plus grande repr\u00e9sentable vaut \\(2^{n-1}\\) Le bit de poids le plus fort ( \\(c_{n-1}\\) ) est appel\u00e9 MSB (Most Significant Bit). Le bit de poids le plus faible ( \\(c_0\\) ) est appel\u00e9 LSB (Low Significant Bit). Un regroupement successif de 4 bits s'appelle un quartet . Un regroupement successif de 8 bits s'appelle un octet . Un regroupement successif de k bits (k > 8) s'appelle un mot de k bits.","title":"Num\u00e9ration binaire (base 2)"},{"location":"2_Representation_information/entiers_positifs/#numeration-hexadecimale-base-16","text":"Ce syst\u00e8me de num\u00e9ration est tr\u00e8s utilis\u00e9 dans l\u2019analyse du fonctionnement de syst\u00e8mes ordinateurs et micro-ordinateurs ainsi que dans le domaine des transmissions de donn\u00e9es. Cette base correspond \u00e0 une contraction d\u2019\u00e9criture de la base 2. Il comporte 16 symboles : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F . Pour indiquer la base 16, on peut utiliser le caract\u00e8re $ (dollar) devant le nombre, ou alors 16# devant le nombre. Exemple : \\(A8_{16}\\) = 16#A8 = $A8 On \u00e9crit : \\[ N = c_{n\u22121} \\times 16^{n\u22121} + c_{n\u22122} \\times 16^{n\u22122} + ... + c_{1} \\times 16^{1} + c_{0} \\times 16^{0} \\] Exemple : Que repr\u00e9sente la valeur $A8 ? \\(A8_{16} =10 \\times 16^1 + 8 \\times 16^0\\) ce qui vaut 168","title":"Num\u00e9ration hexad\u00e9cimale (base 16)"},{"location":"2_Representation_information/entiers_positifs/#les-changements-de-base","text":"","title":"Les changements de base"},{"location":"2_Representation_information/entiers_positifs/#conversions-directes","text":"Du binaire vers l'hexad\u00e9cimal_ : Pour convertir du binaire vers l'hexad\u00e9cimal, on divise le nombre binaire en quartet, en partant de la droite. Chacun des paquets est ensuite converti en hexad\u00e9cimal. Exemple : 110101110001\u2082 = 1101 0111 0001\u2082 = 16#D71 De l'hexad\u00e9cimal vers le binaire : C'est le processus directement inverse, on \u00e9crit chaque quartet sur 4 bits en binaire en compl\u00e9tant \u00e9ventuellement avec des z\u00e9ros sur la gauche. Exemple : 1C3516 = 0001 1100 0011 0101\u2082","title":"Conversions directes"},{"location":"2_Representation_information/entiers_positifs/#conversions-indirectes","text":"Un nombre entier positif N \u00e9tant donn\u00e9 en base 10, on cherche \u00e0 l'\u00e9crire dans une autre base not\u00e9e b. La m\u00e9thode consiste \u00e0 diviser le nombre d\u00e9cimal N par b et \u00e0 conserver le reste (division enti\u00e8re). Le quotient obtenu est ainsi successivement divis\u00e9 tant qu'il n'est pas nul. Les restes successifs sont \u00e9crits, en commen\u00e7ant par le dernier, de la gauche vers la droite, pour former l'expression de N dans le syst\u00e8me de base b. Du d\u00e9cimal vers le binaire Exemple pour la conversion de 173 en base 2, il faut effectuer des divisions successives par 2 Divisions successives par 2 le r\u00e9sultat est donc 17310 \u2192 10101101\u2082 Du d\u00e9cimal vers l'hexad\u00e9cimal : On reprend la m\u00eame m\u00e9thode mais en divisant par 16 : Divisions successives par 16 le r\u00e9sultat est donc 17310 \u2192 $AD. Remarque : La division euclidienne \u00e9tant source d\u2019erreur de calcul, il est conseill\u00e9 d\u2019effectuer la conversion en base 2 du nombre en base 10 puis de convertir le nombre binaire en base 16.","title":"Conversions indirectes"}]}