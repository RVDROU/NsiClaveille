{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue sur le site NSI du lyc\u00e9e Claveille \u00e0 P\u00e9rigueux.","title":"Home"},{"location":"#bienvenue-sur-le-site-nsi-du-lycee-claveille-a-perigueux","text":"","title":"Bienvenue sur le site NSI du lyc\u00e9e Claveille \u00e0 P\u00e9rigueux."},{"location":"aide/","text":"Aide markdown : https://ens-fr.gitlab.io/mkdocs/markdown-bases/ https://sourcefoundry.org/cinder/ https://bouillotvincent.gitlab.io/pyodide-mkdocs/#introduction https://ferney-nsi.gitlab.io/premiere/chapitre1/","title":"Aide"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/","text":"\u00c9preuve pratique \ud83d\udcbb Vous trouverez ci-dessous l'int\u00e9gralit\u00e9 des sujets de l'\u00e9preuve pratique, disponibles publiquement sur la Banque Nationale des Sujets (novembre 2021). La mise \u00e0 jour pour la session 2022 sera publi\u00e9e en janvier 2022 sur le site Eduscol . La banque d'exercices est publique et peut \u00eatre t\u00e9l\u00e9charg\u00e9e en un pdf unique ici . Sujet 1 Exercice 01.1 Programmer la fonction recherche , prenant en param\u00e8tre un tableau non vide tab (type list ) d'entiers et un entier n , et qui renvoie l'indice de la derni\u00e8re occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples >>> recherche ([ 5 , 3 ], 1 ) 2 >>> recherche ([ 2 , 4 ], 2 ) 0 >>> recherche ([ 2 , 3 , 5 , 2 , 4 ], 2 ) 3 Exercice 01.2 On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es \\((x;y)\\) et \\((x';y')\\) est donn\u00e9e par la formule : \\[d=\\sqrt{(x-x')^2+(y-y')^2}\\] On importe pour cela la fonction racine carr\u00e9e ( sqrt ) du module math de Python. On dispose d'une fonction distance et d'une fonction plus_courte_distance : from math import sqrt # import de la fonction racine carr\u00e9e def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( ... ) ** 2 + ( ... ) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = ... for i in range ( 1 , ... ): if distance ( tab [ i ], depart ) ... : point = ... min_dist = ... return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Recopier sous Python (sans les commentaires) ces deux fonctions puis compl\u00e9ter leur code et ajouter une ou des d\u00e9clarations ( assert ) \u00e0 la fonction distance permettant de v\u00e9rifier la ou les pr\u00e9conditions. Sujet 2 Exercice 02.1 Programmer la fonction moyenne prenant en param\u00e8tre un tableau d'entiers tab (type list ) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide et affiche 'erreur' si le tableau est vide. Exemples : >>> moyenne ([ 5 , 3 , 8 ]) 5.333333333333333 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) 5.5 >>> moyenne ([]) 'erreur' Exercice 02.2 On consid\u00e8re un tableau d'entiers tab (type list dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri,le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Zone de 0 Zone non tri\u00e9e Zone de 1 Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction tri suivante : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = ... j = ... while i != j : if tab [ i ] == 0 : i = ... else : valeur = tab [ j ] tab [ j ] = ... ... j = ... ... Exemple : >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] Sujet 3 Exercice 03.1 Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exercice 03.2 Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False Sujet 4 Exercice 04.1 \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne ([ 1 ]) == 1 assert moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] == 4 assert moyenne ([ 1 , 2 ]) == 1.5 Exercice 04.2 Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide. L'algorithme est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient False en renvoyant False,1 , False,2 et False,3 . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ... : return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ... : return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) Sujet 5 Exercice 05.1 On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau [1, 0, 1, 0, 0, 1, 1] repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est 2**6 + 2**4 + 2**1 + 2**0 = 83 . \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : def convertir ( T ): \"\"\" T est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau T \"\"\" Exemple : >>> convertir ([ 1 , 0 , 1 , 0 , 0 , 1 , 1 ]) 83 >>> convertir ([ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ]) 130 Exercice 05.2 La fonction tri_insertion suivante prend en argument une liste L et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if ... : return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > ... : i = ... # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , ... ): L [ k ] = L [ ... ] L [ i ] = ... return L Exemples : >>> tri_insertion ([ 2 , 5 , - 1 , 7 , 0 , 28 ]) [ - 1 , 0 , 2 , 5 , 7 , 28 ] >>> tri_insertion ([ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] Sujet 6 Exercice 06.1 On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e rendu dont le param\u00e8tre est un entier positif non nul somme_a_rendre et qui retourne une liste de trois entiers n1 , n2 et n3 qui correspondent aux nombres de billets de 5 euros ( n1 ) de pi\u00e8ces de 2 euros ( n2 ) et de pi\u00e8ces de 1 euro ( n3 ) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 somme_a_rendre . On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : >>> rendu ( 13 ) [ 2 , 1 , 1 ] >>> rendu ( 64 ) [ 12 , 2 , 0 ] >>> rendu ( 89 ) [ 17 , 2 , 0 ] Exercice 06.2 \u00e0 noter une erreur dans la version officielle, sur la m\u00e9thode enfile() On veut \u00e9crire une classe pour g\u00e9rer une file \u00e0 l\u2019aide d\u2019une liste cha\u00een\u00e9e. On dispose d\u2019une classe Maillon permettant la cr\u00e9ation d\u2019un maillon de la cha\u00eene, celui-ci \u00e9tant constitu\u00e9 d\u2019une valeur et d\u2019une r\u00e9f\u00e9rence au maillon suivant de la cha\u00eene : ```python linenums='1' class Maillon : def __init__(self,v) : self.valeur = v self.suivant = None ``` Compl\u00e9ter la classe ```File suivante``` o\u00f9 l\u2019attribut ```dernier_file``` contient le maillon correspondant \u00e0 l\u2019\u00e9l\u00e9ment arriv\u00e9 en dernier dans la file : ```python linenums='1' class File : def __init__(self) : self.dernier_file = None def enfile(self,element) : nouveau_maillon = Maillon(...) nouveau_maillon.suivant = self.dernier_file self.dernier_file = ... def est_vide(self) : return self.dernier_file == None def affiche(self) : maillon = self.dernier_file while maillon != ... : print(maillon.valeur) maillon = ... def defile(self) : if not self.est_vide() : if self.dernier_file.suivant == None : resultat = self.dernier_file.valeur self.dernier_file = None return resultat maillon = ... while maillon.suivant.suivant != None : maillon = maillon.suivant resultat = ... maillon.suivant = None return resultat return None ``` On pourra tester le fonctionnement de la classe en utilisant les commandes suivantes dans la console Python : ```python >>> F = File() >>> F.est_vide() True >>> F.enfile(2) >>> F.affiche() 2 >>> F.est_vide() False >>> F.enfile(5) >>> F.enfile(7) >>> F.affiche() 7 5 2 >>> F.defile() 2 >>> F.defile() 5 >>> F.affiche() 7 ``` Sujet 7 Exercice 07.1 On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par U1 = 1 , U2 = 1 et, pour tout entier naturel n , par Un+2 = Un+1 + Un . Elle s\u2019appelle la suite de Fibonacci. \u00c9crire la fonction fibonacci qui prend un entier n > 0 et qui renvoie l\u2019\u00e9l\u00e9ment d\u2019indice n de cette suite. On utilisera une programmation dynamique (pas de r\u00e9cursivit\u00e9). Exemple : >>> fibonacci ( 1 ) 1 >>> fibonacci ( 2 ) 1 >>> fibonacci ( 25 ) 75025 >>> fibonacci ( 45 ) 1134903170 Exercice 07.2 Les variables liste_eleves et liste_notes ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction meilleures_notes renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction meilleures_notes ci-dessous. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range ( ... ): if liste_notes [ compteur ] == ... : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ ... ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = ... liste_maxi = [ ... ] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Une fois compl\u00e9t\u00e9, le code ci-dessus donne >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) Sujet 8 Exercice 08.1 \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 Exercice 08.2 On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets - le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] - (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre), on cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) On devra obtenir : >>> rendu_glouton ( 68 ,[], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton ( 291 ,[], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] Sujet 9 Exercice 09.1 Soit le couple ( note , coefficient ): note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples ( note , coefficient ). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer le r\u00e9sultat du calcul suivant : \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) Exercice 09.2 On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : Compl\u00e9ter la fonction pascal ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne 1 \u00e0 la ligne n o\u00f9 n est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 2 (le tableau sera contenu dans la variable C ). La variable Ck doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro k , la k -i\u00e8me ligne du tableau. 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , ... ): Ck = [ ... ] for i in range ( 1 , k ): Ck . append ( C [ ... ][ i - 1 ] + C [ ... ][ ... ] ) Ck . append ( ... ) C . append ( Ck ) return C Pour n = 4 , voici ce qu'on devra obtenir : >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] Sujet 10 Exercice 10.1 \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) Exercice 10.2 Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type list ). On rappelle que l\u2019expression T1 = list(T) fait une copie de T ind\u00e9pendante de T , que l\u2019expression x = T.pop() enl\u00e8ve le sommet de la pile T et le place dans la variable x et, enfin, que l\u2019expression T.append(v) place la valeur v au sommet de la pile T . Compl\u00e9ter le code Python de la fonction positif ci-dessous qui prend une pile T de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable T . 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = ... ( T ) T3 = ... while T2 != []: x = ... if ... >= 0 : T3 . append ( ... ) T2 = [] while T3 != ... : x = T3 . pop () ... print ( 'T = ' , T ) return T2 Exemple : >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) T = [ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ] [ 0 , 5 , 4 , 10 , 9 ] Sujet 11 Exercice 11.1 \u00c9crire une fonction conv_bin qui prend en param\u00e8tre un entier positif n et renvoie un couple ( b,bit) o\u00f9 : b est une liste d'entiers correspondant \u00e0 la repr\u00e9sentation binaire de n ; bit correspond aux nombre de bits qui constituent b . Exemple : >>> conv_bin ( 9 ) ([ 1 , 0 , 0 , 1 ], 4 ) Aide : l'op\u00e9rateur // donne le quotient de la division euclidienne : 5//2 donne 2 ; l'op\u00e9rateur % donne le reste de la division euclidienne : 5%2 donne 1 ; append est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit T=[5,2,4] , alors T.append(10) ajoute 10 \u00e0 la liste T . Ainsi, T devient [5,2,4,10] . reverse est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit T=[5,2,4,10] . Apr\u00e8s T.reverse() , la liste devient [10,4,2,5] . On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier n en partant de la gauche en appliquant successivement les instructions : b = n%2 n = n//2 r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. Exercice 11.2 La fonction tri_bulles prend en param\u00e8tre une liste T d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles . 1 2 3 4 5 6 7 8 9 def tri_bulles ( T ): n = len ( T ) for i in range ( ... , ... , - 1 ): for j in range ( i ): if T [ j ] > T [ ... ]: ... = T [ j ] T [ j ] = T [ ... ] T [ j + 1 ] = temp return T \u00c9crire une autre version de l\u2019algorithme avec for i in range ( n - 1 ): en lieu et place de la troisi\u00e8me ligne du code pr\u00e9c\u00e9dent. Sujet 12 Exercice 12.1 Ce sujet est le m\u00eame que le 10.1... \u00af\\_(\u30c4)_/\u00af \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : ```python >>> maxi([1,5,6,9,1,2,3,7,9,8]) (9,3) ``` Exercice 12.2 La fonction recherche prend en param\u00e8tres deux chaines de caract\u00e8res gene et seq_adn et renvoie True si on retrouve gene dans seq_adn et False sinon. Compl\u00e9ter le code Python ci-dessous pour qu\u2019il impl\u00e9mente la fonction recherche . 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = ... trouve = False while i < ... and trouve == ... : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: ... if j == g : trouve = True ... return trouve Exemples : >>> recherche ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> recherche ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False Sujet 13 Exercice 13.1 \u00c9crire une fonction tri_selection qui prend en param\u00e8tre une liste tab de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : >>> tri_selection ([ 1 , 52 , 6 , - 9 , 12 ]) [ - 9 , 1 , 6 , 12 , 52 ] Exercice 13.2 Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction randint est utilis\u00e9e. Si a et b sont des entiers, randint(a,b) renvoie un nombre entier compris entre a et b . Compl\u00e9ter le code ci-dessous et le tester : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , ... ) nb_test = int ( input ( \"Proposez un nombre entre 1 et 99 : \" )) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test : nb_test = int ( input ( \"Trop petit ! Testez encore : \" )) else : nb_test = int ( input ( \"Trop grand ! Testez encore : \" )) if nb_mystere == nb_test : print ( \"Bravo ! Le nombre \u00e9tait \" , ... ) print ( \"Nombre d'essais: \" , ... ) else : print ( \"Perdu ! Le nombre \u00e9tait \" , ... ) Sujet 14 Exercice 14.1 \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre et tab un tableau de nombres, et qui renvoie le tableau des indices de elt dans tab si elt est dans tab et le tableau vide [] sinon. Exemples : >>> recherche ( 3 , [ 3 , 2 , 1 , 3 , 2 , 1 ]) [ 0 , 3 ] >>> recherche ( 4 , [ 1 , 2 , 3 ]) [] Exercice 14.2 Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : les clefs sont les noms des \u00e9l\u00e8ves ; les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients. Avec : resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ces \u00e9l\u00e8ves et lui renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom ): if nom in ... : notes = resultats [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 Sujet 15 Exercice 15.1 \u00c9crire une fonction rechercheMinMax qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s tab , et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> tableau = [ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : - 2 , 'max' : 9 } >>> tableau = [] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : None , 'max' : None } Exercice 15.2 On dispose d\u2019un programme permettant de cr\u00e9er un objet de type PaquetDeCarte , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par #A compl\u00e9ter , puis ajouter des assertions dans l\u2019initialiseur de Carte , ainsi que dans la m\u00e9thode getCarteAt() . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): #A compl\u00e9ter \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): #A compl\u00e9ter Exemple : >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) Sujet 16 Exercice 16.1 \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 Exercice 16.2 On consid\u00e8re la fonction dec_to_bin ci-dessous qui prend en param\u00e8tre un entier positif a en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = ... a = a // 2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter la fonction dec_to_bin . Exemples : >>> dec_to_bin ( 83 ) '1010011' >>> dec_to_bin ( 127 ) '1111111' Sujet 17 Exercice 17.1 \u00c9crire une fonction indice_du_min qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> indice_du_min ([ 5 ]) 0 >>> indice_du_min ([ 2 , 4 , 1 ]) 2 >>> indice_du_min ([ 5 , 3 , 2 , 2 , 4 ]) 2 Exercice 17.2 On consid\u00e8re la fonction separe ci-dessous qui prend en argument un tableau tab dont les \u00e9l\u00e9ments sont des 0 et des 1 et qui s\u00e9pare les 0 des 1 en pla\u00e7ant les 0 en d\u00e9but de tableau et les 1 \u00e0 la suite. 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = ... while i < j : if tab [ i ] == 0 : i = ... else : tab [ i ], tab [ j ] = ... j = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] Sujet 18 Exercice 18.1 \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 Exercice 18.2 On consid\u00e8re la fonction insere ci-dessous qui prend en argument un entier a et un tableau tab d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur a dans le tableau et renvoie le nouveau tableau. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes python. Sujet l\u00e9g\u00e8rement modifi\u00e9 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = ... while a < ... and i >= ... : l [ i + 1 ] = ... l [ i ] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : >>> insere ( 3 ,[ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 10 ,[ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 10 , 12 , 14 , 25 ] >>> insere ( 1 ,[ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] Sujet 19 Exercice 19.1 \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, -1 sinon. Exemples : >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 Exercice 19.2 Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve et -1 sinon. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for ... in message : if lettre in ALPHABET : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' Sujet 20 Exercice 20.1 On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] \u00c9crire la fonction mini qui prend en param\u00e8tres le tableau releve des relev\u00e9s et le tableau date des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. Exemple : >>> mini ( t_moy , annees ) ( 12.5 , 2016 ) Exercice 20.2 Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : bob , radar , et non sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction est_nbre_palindrome s\u2019appuiera sur la fonction est_palindrome qui elle-m\u00eame s\u2019appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res chaine et renvoie la cha\u00eene invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbre_palindrome teste si un nombre nbre est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. def inverse_chaine ( chaine ): result = ... for caractere in chaine : result = ... return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return ... def est_nbre_palindrome ( nbre ): chaine = ... return est_palindrome ( chaine ) Exemples : >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True Sujet 21 Exercice 21.1 \u00c9crire une fonction python appel\u00e9e nb_repetitions qui prend en param\u00e8tres un \u00e9l\u00e9ment elt et une liste tab et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : >>> nb_repetitions ( 5 ,[ 2 , 5 , 3 , 5 , 6 , 9 , 5 ]) 3 >>> nb_repetitions ( 'A' ,[ 'B' , 'A' , 'B' , 'A' , 'R' ]) 2 >>> nb_repetitions ( 12 ,[ 1 , '! ' , 7 , 21 , 36 , 44 ]) 0 Exercice 21.2 Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( ... ) a = a // 2 while a ... : bin_a = ... ( a % 2 ) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' Sujet 22 Exercice 22.1 \u00c9crire en langage Python une fonction recherche prenant comme param\u00e8tres une variable a de type num\u00e9rique ( float ou int ) et un tableau t (type list ) et qui renvoie le nombre d'occurrences de a dans t . Exemples : >>> recherche ( 5 ,[]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 4 , 8 ]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 1 , 5 , 3 , 7 , 4 ]) 1 >>> recherche ( 5 ,[ - 2 , 5 , 3 , 5 , 4 , 5 ]) 3 Exercice 22.2 La fonction rendu_monnaie_centimes prend en param\u00e8tres deux nombres entiers positifs s_due et s_versee et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence s_versee \u2013 s_due pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. La fonction renvoie la liste des pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en centimes d\u2019euros. Les valeurs possibles pour les pi\u00e8ces sont donc [1, 2, 5, 10, 20, 50, 100, 200] . Ainsi, l\u2019instruction rendu_monnaie_centimes(452, 500) renverra [20, 20, 5, 2, 1] . En effet, la somme \u00e0 rendre est de 48 centimes soit 20 + 20 + 5 + 2 + 1 . Le code de la fonction est donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = ... a_rendre = ... i = len ( pieces ) - 1 while a_rendre > ... : if pieces [ i ] <= a_rendre : rendu . append ( ... ) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code pour qu'il donne : >>> rendu_monnaie_centimes ( 700 , 700 ) [] >>> rendu_monnaie_centimes ( 112 , 500 ) [ 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 ] Sujet 23 Exercice 23.1 L\u2019occurrence d\u2019un caract\u00e8re dans un phrase est le nombre de fois o\u00f9 ce caract\u00e8re est pr\u00e9sent. Exemples : l\u2019occurrence du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; l\u2019occurrence du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : {'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1} \u00c9crire une fonction occurence_lettres prenant comme param\u00e8tre une variable phrase de type str . Cette fonction doit renvoyer un dictionnaire de type constitu\u00e9 des occurrences des caract\u00e8res pr\u00e9sents dans la phrase. Exercice 23.2 La fonction fusion prend deux listes L1 , L2 d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e L12 qu\u2019elle renvoie. Le code Python de la fonction est 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = ... i1 = ... else : L12 [ i ] = L2 [ i2 ] i2 = ... i += 1 while i1 < n1 : L12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : L12 [ i ] = ... i2 = i2 + 1 i = ... return L12 Compl\u00e9ter le code. Exemple : >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] Sujet 24 identique au 18.1 Exercice 24.1 \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 Exercice 24.2 On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de 192.168.0.0 \u00e0 192.168.0.255 . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP 192.168.0.0 et 192.168.0.255 sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe AdresseIP . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class AdresseIP : def __init__ ( self , adresse ): self . adresse = ... def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254 : octet_nouveau = ... + ... return AdresseIP ( '192.168.0.' + ... ) else : return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' Sujet 25 Exercice 25.1 \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] Exercice 25.2 Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M , deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M,2,1,3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == ... ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( ... ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , ... , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( ... ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , ... , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( ... ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , ... , val ) Exemple : >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] Sujet 26 Exercice 26.1 \u00c9crire une fonction occurrence_max prenant en param\u00e8tres une cha\u00eene de caract\u00e8res chaine et qui renvoie le caract\u00e8re le plus fr\u00e9quent de la cha\u00eene. La chaine ne contient que des lettres en minuscules sans accent. On pourra s\u2019aider du tableau alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o,','p','q','r','s','t','u','v','w','x','y','z'] et du tableau occurrence de 26 \u00e9l\u00e9ments o\u00f9 l\u2019on mettra dans occurrence[i] le nombre d\u2019apparitions de alphabet[i] dans la chaine. Puis on calculera l\u2019indice k d\u2019un maximum du tableau occurrence et on affichera alphabet[k] . Exemple : >>> ch = 'je suis en terminale et je passe le bac et je souhaite poursuivre des etudes pour devenir expert en informatique' >>> occurrence_max ( ch ) \u2018 e \u2019 Exercice 26.2 On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Compl\u00e9ter le programme ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return ... def nbCol ( image ): '''renvoie la largeur de l'image''' return ... def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): L [ i ][ j ] = ... return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): if image [ i ][ j ] < ... : L [ i ][ j ] = ... else : L [ i ][ j ] = ... return L Exemple : >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 287 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , - 32 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( negatif ( img ), 120 ) [[ 1 , 1 , 0 , 0 , 1 ], [ 1 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 ], [ 0 , 1 , 1 , 0 , 0 ]] Sujet 27 Exercice 27.1 \u00c9crire une fonction moyenne prenant en param\u00e8tres une liste d\u2019entiers et qui renvoie la moyenne des valeurs de cette liste. Exemple : >>> moyenne ([ 10 , 20 , 30 , 40 , 60 , 110 ]) 45.0 Exercice 27.2 On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction affiche permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction zoomListe prend en argument une liste liste_depart et un entier k . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de liste_depart est dupliqu\u00e9 k fois. La fonction zoomDessin prend en argument la grille dessin et renvoie une grille o\u00f9 toutes les lignes de dessin sont zoom\u00e9es k fois et r\u00e9p\u00e9t\u00e9es k fois. Soit le code ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin : for col in ligne : if col == 1 : print ( \" *\" , end = \"\" ) else : print ( \" \" , end = \"\" ) print () def zoomListe ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range ( k ): ... return liste_zoom def zoomDessin ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom = [] for elt in grille : liste_zoom = ... for i in range ( k ): ... . append ( ... ) return grille_zoom R\u00e9sultats \u00e0 obtenir : >>> affiche ( coeur ) >>> affiche ( zoomDessin ( coeur , 3 )) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * Sujet 28 Exercice 28.1 Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre est stock\u00e9 dans a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], \\ 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], \\ 'H' :[ '' , '' ]} \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tres un arbre binaire arbre sous la forme d\u2019un dictionnaire et un caract\u00e8re lettre qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153ud. On pourra distinguer les 4 cas o\u00f9 les deux \u00ab fils \u00bb du n\u0153ud sont '' , le fils gauche seulement est '' , le fils droit seulement est '' , aucun des deux fils n\u2019est '' . Exemple : >>> taille ( a , \u2019 F \u2019 ) 9 Exercice 28.2 On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt depuis le d\u00e9but du tableau tous les \u00e9l\u00e9ments non rang\u00e9s et on place en derni\u00e8re position le plus grand \u00e9l\u00e9ment. Exemple avec le tableau : t = [41, 55, 21, 18, 12, 6, 25] \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus grand \u00e9l\u00e9ment avec le dernier. Le tableau devient t = [41, 25, 21, 18, 12, 6, 55] \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le dernier , on permute le plus grand \u00e9l\u00e9ment trouv\u00e9 avec l'avant dernier. Le tableau devient : t = [6, 25, 21, 18, 12, 41, 55] Et ainsi de suite. La code de la fonction tri_iteratif qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( ... , 0 , - 1 ): imax = ... for i in range ( 0 , ... ): if tab [ i ] > ... : imax = i if tab [ max ] > ... : ... , tab [ imax ] = tab [ imax ], ... return tab Compl\u00e9ter le code qui doit donner : >>> tri_iteratif ([ 41 , 55 , 21 , 18 , 12 , 6 , 25 ]) [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et b . Sujet 29 Exercice 29.1 Soit un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 1 : s'il est pair, on le divise par 2 ; s\u2019il est impair, on le multiplie par 3 et on ajoute 1. Puis on recommence ces \u00e9tapes avec le nombre entier obtenu, jusqu\u2019\u00e0 ce que l\u2019on obtienne la valeur 1. On d\u00e9finit ainsi la suite \\((U_n)\\) par : \\(U_0=k\\) , o\u00f9 \\(k\\) est un entier choisi initialement; \\(U_{n+1} = \\dfrac{U_n}{2}\\) si \\(U_n\\) est pair; \\(U_{n+1} = 3 \\times U_n + 1\\) si \\(U_n\\) est impair. On admet que, quel que soit l'entier k choisi au d\u00e9part, la suite finit toujours sur la valeur 1. \u00c9crire une fonction calcul prenant en param\u00e8tres un entier n strictement positif et qui renvoie la liste des valeurs de la suite, en partant de n et jusqu'\u00e0 atteindre 1. Exemple : >>> calcul ( 7 ) [ 7 , 22 , 11 , 34 , 17 , 52 , 26 , 13 , 40 , 20 , 10 , 5 , 16 , 8 , 4 , 2 , 1 ] Exercice 29.2 On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction est_parfait ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res mot (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de mot , ainsi qu\u2019un bool\u00e9en qui indique si mot est parfait ou pas. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = ??? for c in mot : code_c = code_c + ??? code_a = ??? code_c = int ( code_c ) if ??? : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] Exemples : >>> est_parfait ( \"PAUL\" ) [ 50 , 1612112 , False ] >>> est_parfait ( \"ALAIN\" ) [ 37 , 1121914 , True ] Sujet 30 Exercice 30.1 Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 Exercice 30.2 Soit T un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et n un entier. La fonction chercher , donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur n appara\u00eet \u00e9ventuellement dans T , et None sinon. Les param\u00e8tres de la fonction sont : T , le tableau dans lequel s'effectue la recherche ; n , l'entier \u00e0 chercher dans le tableau ; i , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; j , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction chercher est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si 0 <= i et j < len(T) . Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche \"Erreur\" puis renvoie None . Recopier et compl\u00e9ter le code de la fonction chercher propos\u00e9e ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or ??? : print ( \"Erreur\" ) return None if i > j : return None m = ( i + j ) // ??? if T [ m ] < ??? : return chercher ( T , n , ??? , ??? ) elif ??? : return chercher ( T , n , ??? , ??? ) else : return ??? L'ex\u00e9cution du code doit donner : >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) Erreur >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2","title":"Annales des \u00e9preuves pratiques"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#epreuve-pratique","text":"Vous trouverez ci-dessous l'int\u00e9gralit\u00e9 des sujets de l'\u00e9preuve pratique, disponibles publiquement sur la Banque Nationale des Sujets (novembre 2021). La mise \u00e0 jour pour la session 2022 sera publi\u00e9e en janvier 2022 sur le site Eduscol . La banque d'exercices est publique et peut \u00eatre t\u00e9l\u00e9charg\u00e9e en un pdf unique ici .","title":"\u00c9preuve pratique \ud83d\udcbb"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-1","text":"Exercice 01.1 Programmer la fonction recherche , prenant en param\u00e8tre un tableau non vide tab (type list ) d'entiers et un entier n , et qui renvoie l'indice de la derni\u00e8re occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples >>> recherche ([ 5 , 3 ], 1 ) 2 >>> recherche ([ 2 , 4 ], 2 ) 0 >>> recherche ([ 2 , 3 , 5 , 2 , 4 ], 2 ) 3 Exercice 01.2 On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es \\((x;y)\\) et \\((x';y')\\) est donn\u00e9e par la formule : \\[d=\\sqrt{(x-x')^2+(y-y')^2}\\] On importe pour cela la fonction racine carr\u00e9e ( sqrt ) du module math de Python. On dispose d'une fonction distance et d'une fonction plus_courte_distance : from math import sqrt # import de la fonction racine carr\u00e9e def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( ... ) ** 2 + ( ... ) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = ... for i in range ( 1 , ... ): if distance ( tab [ i ], depart ) ... : point = ... min_dist = ... return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Recopier sous Python (sans les commentaires) ces deux fonctions puis compl\u00e9ter leur code et ajouter une ou des d\u00e9clarations ( assert ) \u00e0 la fonction distance permettant de v\u00e9rifier la ou les pr\u00e9conditions.","title":"Sujet 1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-2","text":"Exercice 02.1 Programmer la fonction moyenne prenant en param\u00e8tre un tableau d'entiers tab (type list ) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide et affiche 'erreur' si le tableau est vide. Exemples : >>> moyenne ([ 5 , 3 , 8 ]) 5.333333333333333 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) 5.5 >>> moyenne ([]) 'erreur' Exercice 02.2 On consid\u00e8re un tableau d'entiers tab (type list dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri,le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Zone de 0 Zone non tri\u00e9e Zone de 1 Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction tri suivante : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = ... j = ... while i != j : if tab [ i ] == 0 : i = ... else : valeur = tab [ j ] tab [ j ] = ... ... j = ... ... Exemple : >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ]","title":"Sujet 2"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-3","text":"Exercice 03.1 Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exercice 03.2 Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False","title":"Sujet 3"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-4","text":"Exercice 04.1 \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne ([ 1 ]) == 1 assert moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] == 4 assert moyenne ([ 1 , 2 ]) == 1.5 Exercice 04.2 Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide. L'algorithme est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient False en renvoyant False,1 , False,2 et False,3 . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ... : return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ... : return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 )","title":"Sujet 4"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-5","text":"Exercice 05.1 On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau [1, 0, 1, 0, 0, 1, 1] repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est 2**6 + 2**4 + 2**1 + 2**0 = 83 . \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : def convertir ( T ): \"\"\" T est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau T \"\"\" Exemple : >>> convertir ([ 1 , 0 , 1 , 0 , 0 , 1 , 1 ]) 83 >>> convertir ([ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ]) 130 Exercice 05.2 La fonction tri_insertion suivante prend en argument une liste L et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if ... : return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > ... : i = ... # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , ... ): L [ k ] = L [ ... ] L [ i ] = ... return L Exemples : >>> tri_insertion ([ 2 , 5 , - 1 , 7 , 0 , 28 ]) [ - 1 , 0 , 2 , 5 , 7 , 28 ] >>> tri_insertion ([ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]","title":"Sujet 5"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-6","text":"Exercice 06.1 On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e rendu dont le param\u00e8tre est un entier positif non nul somme_a_rendre et qui retourne une liste de trois entiers n1 , n2 et n3 qui correspondent aux nombres de billets de 5 euros ( n1 ) de pi\u00e8ces de 2 euros ( n2 ) et de pi\u00e8ces de 1 euro ( n3 ) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 somme_a_rendre . On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : >>> rendu ( 13 ) [ 2 , 1 , 1 ] >>> rendu ( 64 ) [ 12 , 2 , 0 ] >>> rendu ( 89 ) [ 17 , 2 , 0 ] Exercice 06.2 \u00e0 noter une erreur dans la version officielle, sur la m\u00e9thode enfile() On veut \u00e9crire une classe pour g\u00e9rer une file \u00e0 l\u2019aide d\u2019une liste cha\u00een\u00e9e. On dispose d\u2019une classe Maillon permettant la cr\u00e9ation d\u2019un maillon de la cha\u00eene, celui-ci \u00e9tant constitu\u00e9 d\u2019une valeur et d\u2019une r\u00e9f\u00e9rence au maillon suivant de la cha\u00eene : ```python linenums='1' class Maillon : def __init__(self,v) : self.valeur = v self.suivant = None ``` Compl\u00e9ter la classe ```File suivante``` o\u00f9 l\u2019attribut ```dernier_file``` contient le maillon correspondant \u00e0 l\u2019\u00e9l\u00e9ment arriv\u00e9 en dernier dans la file : ```python linenums='1' class File : def __init__(self) : self.dernier_file = None def enfile(self,element) : nouveau_maillon = Maillon(...) nouveau_maillon.suivant = self.dernier_file self.dernier_file = ... def est_vide(self) : return self.dernier_file == None def affiche(self) : maillon = self.dernier_file while maillon != ... : print(maillon.valeur) maillon = ... def defile(self) : if not self.est_vide() : if self.dernier_file.suivant == None : resultat = self.dernier_file.valeur self.dernier_file = None return resultat maillon = ... while maillon.suivant.suivant != None : maillon = maillon.suivant resultat = ... maillon.suivant = None return resultat return None ``` On pourra tester le fonctionnement de la classe en utilisant les commandes suivantes dans la console Python : ```python >>> F = File() >>> F.est_vide() True >>> F.enfile(2) >>> F.affiche() 2 >>> F.est_vide() False >>> F.enfile(5) >>> F.enfile(7) >>> F.affiche() 7 5 2 >>> F.defile() 2 >>> F.defile() 5 >>> F.affiche() 7 ```","title":"Sujet 6"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-7","text":"Exercice 07.1 On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par U1 = 1 , U2 = 1 et, pour tout entier naturel n , par Un+2 = Un+1 + Un . Elle s\u2019appelle la suite de Fibonacci. \u00c9crire la fonction fibonacci qui prend un entier n > 0 et qui renvoie l\u2019\u00e9l\u00e9ment d\u2019indice n de cette suite. On utilisera une programmation dynamique (pas de r\u00e9cursivit\u00e9). Exemple : >>> fibonacci ( 1 ) 1 >>> fibonacci ( 2 ) 1 >>> fibonacci ( 25 ) 75025 >>> fibonacci ( 45 ) 1134903170 Exercice 07.2 Les variables liste_eleves et liste_notes ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction meilleures_notes renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction meilleures_notes ci-dessous. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range ( ... ): if liste_notes [ compteur ] == ... : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ ... ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = ... liste_maxi = [ ... ] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Une fois compl\u00e9t\u00e9, le code ci-dessus donne >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ])","title":"Sujet 7"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-8","text":"Exercice 08.1 \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 Exercice 08.2 On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets - le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] - (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre), on cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) On devra obtenir : >>> rendu_glouton ( 68 ,[], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton ( 291 ,[], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ]","title":"Sujet 8"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-9","text":"Exercice 09.1 Soit le couple ( note , coefficient ): note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples ( note , coefficient ). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer le r\u00e9sultat du calcul suivant : \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) Exercice 09.2 On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : Compl\u00e9ter la fonction pascal ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne 1 \u00e0 la ligne n o\u00f9 n est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 2 (le tableau sera contenu dans la variable C ). La variable Ck doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro k , la k -i\u00e8me ligne du tableau. 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , ... ): Ck = [ ... ] for i in range ( 1 , k ): Ck . append ( C [ ... ][ i - 1 ] + C [ ... ][ ... ] ) Ck . append ( ... ) C . append ( Ck ) return C Pour n = 4 , voici ce qu'on devra obtenir : >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]]","title":"Sujet 9"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-10","text":"Exercice 10.1 \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) Exercice 10.2 Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type list ). On rappelle que l\u2019expression T1 = list(T) fait une copie de T ind\u00e9pendante de T , que l\u2019expression x = T.pop() enl\u00e8ve le sommet de la pile T et le place dans la variable x et, enfin, que l\u2019expression T.append(v) place la valeur v au sommet de la pile T . Compl\u00e9ter le code Python de la fonction positif ci-dessous qui prend une pile T de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable T . 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = ... ( T ) T3 = ... while T2 != []: x = ... if ... >= 0 : T3 . append ( ... ) T2 = [] while T3 != ... : x = T3 . pop () ... print ( 'T = ' , T ) return T2 Exemple : >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) T = [ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ] [ 0 , 5 , 4 , 10 , 9 ]","title":"Sujet 10"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-11","text":"Exercice 11.1 \u00c9crire une fonction conv_bin qui prend en param\u00e8tre un entier positif n et renvoie un couple ( b,bit) o\u00f9 : b est une liste d'entiers correspondant \u00e0 la repr\u00e9sentation binaire de n ; bit correspond aux nombre de bits qui constituent b . Exemple : >>> conv_bin ( 9 ) ([ 1 , 0 , 0 , 1 ], 4 ) Aide : l'op\u00e9rateur // donne le quotient de la division euclidienne : 5//2 donne 2 ; l'op\u00e9rateur % donne le reste de la division euclidienne : 5%2 donne 1 ; append est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit T=[5,2,4] , alors T.append(10) ajoute 10 \u00e0 la liste T . Ainsi, T devient [5,2,4,10] . reverse est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit T=[5,2,4,10] . Apr\u00e8s T.reverse() , la liste devient [10,4,2,5] . On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier n en partant de la gauche en appliquant successivement les instructions : b = n%2 n = n//2 r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. Exercice 11.2 La fonction tri_bulles prend en param\u00e8tre une liste T d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles . 1 2 3 4 5 6 7 8 9 def tri_bulles ( T ): n = len ( T ) for i in range ( ... , ... , - 1 ): for j in range ( i ): if T [ j ] > T [ ... ]: ... = T [ j ] T [ j ] = T [ ... ] T [ j + 1 ] = temp return T \u00c9crire une autre version de l\u2019algorithme avec for i in range ( n - 1 ): en lieu et place de la troisi\u00e8me ligne du code pr\u00e9c\u00e9dent.","title":"Sujet 11"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-12","text":"Exercice 12.1 Ce sujet est le m\u00eame que le 10.1... \u00af\\_(\u30c4)_/\u00af \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : ```python >>> maxi([1,5,6,9,1,2,3,7,9,8]) (9,3) ``` Exercice 12.2 La fonction recherche prend en param\u00e8tres deux chaines de caract\u00e8res gene et seq_adn et renvoie True si on retrouve gene dans seq_adn et False sinon. Compl\u00e9ter le code Python ci-dessous pour qu\u2019il impl\u00e9mente la fonction recherche . 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = ... trouve = False while i < ... and trouve == ... : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: ... if j == g : trouve = True ... return trouve Exemples : >>> recherche ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> recherche ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False","title":"Sujet 12"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-13","text":"Exercice 13.1 \u00c9crire une fonction tri_selection qui prend en param\u00e8tre une liste tab de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : >>> tri_selection ([ 1 , 52 , 6 , - 9 , 12 ]) [ - 9 , 1 , 6 , 12 , 52 ] Exercice 13.2 Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction randint est utilis\u00e9e. Si a et b sont des entiers, randint(a,b) renvoie un nombre entier compris entre a et b . Compl\u00e9ter le code ci-dessous et le tester : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , ... ) nb_test = int ( input ( \"Proposez un nombre entre 1 et 99 : \" )) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test : nb_test = int ( input ( \"Trop petit ! Testez encore : \" )) else : nb_test = int ( input ( \"Trop grand ! Testez encore : \" )) if nb_mystere == nb_test : print ( \"Bravo ! Le nombre \u00e9tait \" , ... ) print ( \"Nombre d'essais: \" , ... ) else : print ( \"Perdu ! Le nombre \u00e9tait \" , ... )","title":"Sujet 13"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-14","text":"Exercice 14.1 \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre et tab un tableau de nombres, et qui renvoie le tableau des indices de elt dans tab si elt est dans tab et le tableau vide [] sinon. Exemples : >>> recherche ( 3 , [ 3 , 2 , 1 , 3 , 2 , 1 ]) [ 0 , 3 ] >>> recherche ( 4 , [ 1 , 2 , 3 ]) [] Exercice 14.2 Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : les clefs sont les noms des \u00e9l\u00e8ves ; les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients. Avec : resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ces \u00e9l\u00e8ves et lui renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom ): if nom in ... : notes = resultats [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1","title":"Sujet 14"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-15","text":"Exercice 15.1 \u00c9crire une fonction rechercheMinMax qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s tab , et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> tableau = [ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : - 2 , 'max' : 9 } >>> tableau = [] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : None , 'max' : None } Exercice 15.2 On dispose d\u2019un programme permettant de cr\u00e9er un objet de type PaquetDeCarte , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par #A compl\u00e9ter , puis ajouter des assertions dans l\u2019initialiseur de Carte , ainsi que dans la m\u00e9thode getCarteAt() . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): #A compl\u00e9ter \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): #A compl\u00e9ter Exemple : >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ())","title":"Sujet 15"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-16","text":"Exercice 16.1 \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 Exercice 16.2 On consid\u00e8re la fonction dec_to_bin ci-dessous qui prend en param\u00e8tre un entier positif a en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = ... a = a // 2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter la fonction dec_to_bin . Exemples : >>> dec_to_bin ( 83 ) '1010011' >>> dec_to_bin ( 127 ) '1111111'","title":"Sujet 16"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-17","text":"Exercice 17.1 \u00c9crire une fonction indice_du_min qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> indice_du_min ([ 5 ]) 0 >>> indice_du_min ([ 2 , 4 , 1 ]) 2 >>> indice_du_min ([ 5 , 3 , 2 , 2 , 4 ]) 2 Exercice 17.2 On consid\u00e8re la fonction separe ci-dessous qui prend en argument un tableau tab dont les \u00e9l\u00e9ments sont des 0 et des 1 et qui s\u00e9pare les 0 des 1 en pla\u00e7ant les 0 en d\u00e9but de tableau et les 1 \u00e0 la suite. 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = ... while i < j : if tab [ i ] == 0 : i = ... else : tab [ i ], tab [ j ] = ... j = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ]","title":"Sujet 17"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-18","text":"Exercice 18.1 \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 Exercice 18.2 On consid\u00e8re la fonction insere ci-dessous qui prend en argument un entier a et un tableau tab d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur a dans le tableau et renvoie le nouveau tableau. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes python. Sujet l\u00e9g\u00e8rement modifi\u00e9 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = ... while a < ... and i >= ... : l [ i + 1 ] = ... l [ i ] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : >>> insere ( 3 ,[ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 10 ,[ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 10 , 12 , 14 , 25 ] >>> insere ( 1 ,[ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ]","title":"Sujet 18"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-19","text":"Exercice 19.1 \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, -1 sinon. Exemples : >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 Exercice 19.2 Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve et -1 sinon. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for ... in message : if lettre in ALPHABET : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !'","title":"Sujet 19"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-20","text":"Exercice 20.1 On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] \u00c9crire la fonction mini qui prend en param\u00e8tres le tableau releve des relev\u00e9s et le tableau date des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. Exemple : >>> mini ( t_moy , annees ) ( 12.5 , 2016 ) Exercice 20.2 Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : bob , radar , et non sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction est_nbre_palindrome s\u2019appuiera sur la fonction est_palindrome qui elle-m\u00eame s\u2019appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res chaine et renvoie la cha\u00eene invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbre_palindrome teste si un nombre nbre est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. def inverse_chaine ( chaine ): result = ... for caractere in chaine : result = ... return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return ... def est_nbre_palindrome ( nbre ): chaine = ... return est_palindrome ( chaine ) Exemples : >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True","title":"Sujet 20"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-21","text":"Exercice 21.1 \u00c9crire une fonction python appel\u00e9e nb_repetitions qui prend en param\u00e8tres un \u00e9l\u00e9ment elt et une liste tab et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : >>> nb_repetitions ( 5 ,[ 2 , 5 , 3 , 5 , 6 , 9 , 5 ]) 3 >>> nb_repetitions ( 'A' ,[ 'B' , 'A' , 'B' , 'A' , 'R' ]) 2 >>> nb_repetitions ( 12 ,[ 1 , '! ' , 7 , 21 , 36 , 44 ]) 0 Exercice 21.2 Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( ... ) a = a // 2 while a ... : bin_a = ... ( a % 2 ) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101'","title":"Sujet 21"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-22","text":"Exercice 22.1 \u00c9crire en langage Python une fonction recherche prenant comme param\u00e8tres une variable a de type num\u00e9rique ( float ou int ) et un tableau t (type list ) et qui renvoie le nombre d'occurrences de a dans t . Exemples : >>> recherche ( 5 ,[]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 4 , 8 ]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 1 , 5 , 3 , 7 , 4 ]) 1 >>> recherche ( 5 ,[ - 2 , 5 , 3 , 5 , 4 , 5 ]) 3 Exercice 22.2 La fonction rendu_monnaie_centimes prend en param\u00e8tres deux nombres entiers positifs s_due et s_versee et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence s_versee \u2013 s_due pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. La fonction renvoie la liste des pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en centimes d\u2019euros. Les valeurs possibles pour les pi\u00e8ces sont donc [1, 2, 5, 10, 20, 50, 100, 200] . Ainsi, l\u2019instruction rendu_monnaie_centimes(452, 500) renverra [20, 20, 5, 2, 1] . En effet, la somme \u00e0 rendre est de 48 centimes soit 20 + 20 + 5 + 2 + 1 . Le code de la fonction est donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = ... a_rendre = ... i = len ( pieces ) - 1 while a_rendre > ... : if pieces [ i ] <= a_rendre : rendu . append ( ... ) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code pour qu'il donne : >>> rendu_monnaie_centimes ( 700 , 700 ) [] >>> rendu_monnaie_centimes ( 112 , 500 ) [ 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 ]","title":"Sujet 22"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-23","text":"Exercice 23.1 L\u2019occurrence d\u2019un caract\u00e8re dans un phrase est le nombre de fois o\u00f9 ce caract\u00e8re est pr\u00e9sent. Exemples : l\u2019occurrence du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; l\u2019occurrence du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : {'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1} \u00c9crire une fonction occurence_lettres prenant comme param\u00e8tre une variable phrase de type str . Cette fonction doit renvoyer un dictionnaire de type constitu\u00e9 des occurrences des caract\u00e8res pr\u00e9sents dans la phrase. Exercice 23.2 La fonction fusion prend deux listes L1 , L2 d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e L12 qu\u2019elle renvoie. Le code Python de la fonction est 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = ... i1 = ... else : L12 [ i ] = L2 [ i2 ] i2 = ... i += 1 while i1 < n1 : L12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : L12 [ i ] = ... i2 = i2 + 1 i = ... return L12 Compl\u00e9ter le code. Exemple : >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ]","title":"Sujet 23"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-24","text":"identique au 18.1 Exercice 24.1 \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 Exercice 24.2 On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de 192.168.0.0 \u00e0 192.168.0.255 . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP 192.168.0.0 et 192.168.0.255 sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe AdresseIP . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class AdresseIP : def __init__ ( self , adresse ): self . adresse = ... def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254 : octet_nouveau = ... + ... return AdresseIP ( '192.168.0.' + ... ) else : return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3'","title":"Sujet 24"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-25","text":"Exercice 25.1 \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] Exercice 25.2 Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M , deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M,2,1,3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == ... ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( ... ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , ... , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( ... ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , ... , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( ... ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , ... , val ) Exemple : >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]]","title":"Sujet 25"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-26","text":"Exercice 26.1 \u00c9crire une fonction occurrence_max prenant en param\u00e8tres une cha\u00eene de caract\u00e8res chaine et qui renvoie le caract\u00e8re le plus fr\u00e9quent de la cha\u00eene. La chaine ne contient que des lettres en minuscules sans accent. On pourra s\u2019aider du tableau alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o,','p','q','r','s','t','u','v','w','x','y','z'] et du tableau occurrence de 26 \u00e9l\u00e9ments o\u00f9 l\u2019on mettra dans occurrence[i] le nombre d\u2019apparitions de alphabet[i] dans la chaine. Puis on calculera l\u2019indice k d\u2019un maximum du tableau occurrence et on affichera alphabet[k] . Exemple : >>> ch = 'je suis en terminale et je passe le bac et je souhaite poursuivre des etudes pour devenir expert en informatique' >>> occurrence_max ( ch ) \u2018 e \u2019 Exercice 26.2 On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Compl\u00e9ter le programme ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return ... def nbCol ( image ): '''renvoie la largeur de l'image''' return ... def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): L [ i ][ j ] = ... return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): if image [ i ][ j ] < ... : L [ i ][ j ] = ... else : L [ i ][ j ] = ... return L Exemple : >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 287 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , - 32 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( negatif ( img ), 120 ) [[ 1 , 1 , 0 , 0 , 1 ], [ 1 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 ], [ 0 , 1 , 1 , 0 , 0 ]]","title":"Sujet 26"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-27","text":"Exercice 27.1 \u00c9crire une fonction moyenne prenant en param\u00e8tres une liste d\u2019entiers et qui renvoie la moyenne des valeurs de cette liste. Exemple : >>> moyenne ([ 10 , 20 , 30 , 40 , 60 , 110 ]) 45.0 Exercice 27.2 On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction affiche permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction zoomListe prend en argument une liste liste_depart et un entier k . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de liste_depart est dupliqu\u00e9 k fois. La fonction zoomDessin prend en argument la grille dessin et renvoie une grille o\u00f9 toutes les lignes de dessin sont zoom\u00e9es k fois et r\u00e9p\u00e9t\u00e9es k fois. Soit le code ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin : for col in ligne : if col == 1 : print ( \" *\" , end = \"\" ) else : print ( \" \" , end = \"\" ) print () def zoomListe ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range ( k ): ... return liste_zoom def zoomDessin ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom = [] for elt in grille : liste_zoom = ... for i in range ( k ): ... . append ( ... ) return grille_zoom R\u00e9sultats \u00e0 obtenir : >>> affiche ( coeur ) >>> affiche ( zoomDessin ( coeur , 3 )) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *","title":"Sujet 27"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-28","text":"Exercice 28.1 Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre est stock\u00e9 dans a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], \\ 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], \\ 'H' :[ '' , '' ]} \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tres un arbre binaire arbre sous la forme d\u2019un dictionnaire et un caract\u00e8re lettre qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153ud. On pourra distinguer les 4 cas o\u00f9 les deux \u00ab fils \u00bb du n\u0153ud sont '' , le fils gauche seulement est '' , le fils droit seulement est '' , aucun des deux fils n\u2019est '' . Exemple : >>> taille ( a , \u2019 F \u2019 ) 9 Exercice 28.2 On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt depuis le d\u00e9but du tableau tous les \u00e9l\u00e9ments non rang\u00e9s et on place en derni\u00e8re position le plus grand \u00e9l\u00e9ment. Exemple avec le tableau : t = [41, 55, 21, 18, 12, 6, 25] \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus grand \u00e9l\u00e9ment avec le dernier. Le tableau devient t = [41, 25, 21, 18, 12, 6, 55] \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le dernier , on permute le plus grand \u00e9l\u00e9ment trouv\u00e9 avec l'avant dernier. Le tableau devient : t = [6, 25, 21, 18, 12, 41, 55] Et ainsi de suite. La code de la fonction tri_iteratif qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( ... , 0 , - 1 ): imax = ... for i in range ( 0 , ... ): if tab [ i ] > ... : imax = i if tab [ max ] > ... : ... , tab [ imax ] = tab [ imax ], ... return tab Compl\u00e9ter le code qui doit donner : >>> tri_iteratif ([ 41 , 55 , 21 , 18 , 12 , 6 , 25 ]) [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et b .","title":"Sujet 28"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-29","text":"Exercice 29.1 Soit un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 1 : s'il est pair, on le divise par 2 ; s\u2019il est impair, on le multiplie par 3 et on ajoute 1. Puis on recommence ces \u00e9tapes avec le nombre entier obtenu, jusqu\u2019\u00e0 ce que l\u2019on obtienne la valeur 1. On d\u00e9finit ainsi la suite \\((U_n)\\) par : \\(U_0=k\\) , o\u00f9 \\(k\\) est un entier choisi initialement; \\(U_{n+1} = \\dfrac{U_n}{2}\\) si \\(U_n\\) est pair; \\(U_{n+1} = 3 \\times U_n + 1\\) si \\(U_n\\) est impair. On admet que, quel que soit l'entier k choisi au d\u00e9part, la suite finit toujours sur la valeur 1. \u00c9crire une fonction calcul prenant en param\u00e8tres un entier n strictement positif et qui renvoie la liste des valeurs de la suite, en partant de n et jusqu'\u00e0 atteindre 1. Exemple : >>> calcul ( 7 ) [ 7 , 22 , 11 , 34 , 17 , 52 , 26 , 13 , 40 , 20 , 10 , 5 , 16 , 8 , 4 , 2 , 1 ] Exercice 29.2 On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction est_parfait ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res mot (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de mot , ainsi qu\u2019un bool\u00e9en qui indique si mot est parfait ou pas. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = ??? for c in mot : code_c = code_c + ??? code_a = ??? code_c = int ( code_c ) if ??? : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] Exemples : >>> est_parfait ( \"PAUL\" ) [ 50 , 1612112 , False ] >>> est_parfait ( \"ALAIN\" ) [ 37 , 1121914 , True ]","title":"Sujet 29"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI/#sujet-30","text":"Exercice 30.1 Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 Exercice 30.2 Soit T un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et n un entier. La fonction chercher , donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur n appara\u00eet \u00e9ventuellement dans T , et None sinon. Les param\u00e8tres de la fonction sont : T , le tableau dans lequel s'effectue la recherche ; n , l'entier \u00e0 chercher dans le tableau ; i , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; j , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction chercher est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si 0 <= i et j < len(T) . Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche \"Erreur\" puis renvoie None . Recopier et compl\u00e9ter le code de la fonction chercher propos\u00e9e ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or ??? : print ( \"Erreur\" ) return None if i > j : return None m = ( i + j ) // ??? if T [ m ] < ??? : return chercher ( T , n , ??? , ??? ) elif ??? : return chercher ( T , n , ??? , ??? ) else : return ??? L'ex\u00e9cution du code doit donner : >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) Erreur >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2","title":"Sujet 30"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/","text":"Exercice 01.1 \u25a1 Exercice 01.1 \u00c9nonc\u00e9 Programmer la fonction recherche , prenant en param\u00e8tre un tableau non vide tab (type list ) d'entiers et un entier n , et qui renvoie l'indice de la derni\u00e8re occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples >>> recherche ([ 5 , 3 ], 1 ) 2 >>> recherche ([ 2 , 4 ], 2 ) 0 >>> recherche ([ 2 , 3 , 5 , 2 , 4 ], 2 ) 3 Correction {{ correction(True, \" 1 2 3 4 5 6 def recherche ( tab , n ): indice_solution = len ( tab ) for i in range ( len ( tab )): if tab [ i ] == n : indice_solution = i return indice_solution \" ) }} Exercice 01.2 \u25a1 Exercice 01.2 \u00c9nonc\u00e9 On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es \\((x;y)\\) et \\((x';y')\\) est donn\u00e9e par la formule : \\[d=\\sqrt{(x-x')^2+(y-y')^2}\\] On importe pour cela la fonction racine carr\u00e9e ( sqrt ) du module math de Python. On dispose d'une fonction distance et d'une fonction plus_courte_distance : from math import sqrt # import de la fonction racine carr\u00e9e def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( ... ) ** 2 + ( ... ) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = ... for i in range ( 1 , ... ): if distance ( tab [ i ], depart ) ... : point = ... min_dist = ... return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Recopier sous Python (sans les commentaires) ces deux fonctions puis compl\u00e9ter leur code et ajouter une ou des d\u00e9clarations ( assert ) \u00e0 la fonction distance permettant de v\u00e9rifier la ou les pr\u00e9conditions. Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from math import sqrt def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( point1 [ 0 ] - point2 [ 0 ]) ** 2 + (( point1 [ 1 ] - point2 [ 1 ])) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = distance ( point , depart ) for i in range ( 1 , len ( tab )): if distance ( tab [ i ], depart ) < min_dist : point = tab [ i ] min_dist = distance ( tab [ i ], depart ) return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Exercice 02.1 \u25a1 Exercice 02.1 \u00c9nonc\u00e9 Programmer la fonction moyenne prenant en param\u00e8tre un tableau d'entiers tab (type list ) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide et affiche 'erreur' si le tableau est vide. Exemples : >>> moyenne ([ 5 , 3 , 8 ]) 5.333333333333333 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) 5.5 >>> moyenne ([]) 'erreur' Correction {{ correction(True, \" L'\u00e9nonc\u00e9 n'est pas tr\u00e8s clair quand il dit \u00abd'afficher 'erreur'\u00bb (ce qui suppose un print et non un return ). Nous choississons donc dans ce cas de renvoyer None . 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): if tab == []: print ( 'erreur' ) return None else : somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \" ) }} Exercice 02.2 \u25a1 Exercice 02.2 \u00c9nonc\u00e9 On consid\u00e8re un tableau d'entiers tab (type list dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri,le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Zone de 0 Zone non tri\u00e9e Zone de 1 Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction tri suivante : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = ... j = ... while i != j : if tab [ i ] == 0 : i = ... else : valeur = tab [ j ] tab [ j ] = ... ... j = ... ... Exemple : >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = 0 j = len ( tab ) - 1 while i != j : if tab [ i ] == 0 : i = i + 1 else : valeur = tab [ j ] tab [ j ] = tab [ i ] tab [ i ] = valeur j = j - 1 return tab \" ) }} Exercice 03.1 \u25a1 Exercice 03.1 \u00c9nonc\u00e9 Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Correction {{ correction(True, \" \u00c9nonc\u00e9 peu clair, on ne sait pas si n1 et n2 sont entiers naturels ou relatifs. Nous d\u00e9cidons qu'ils sont relatifs et donc qu'ils peuvent \u00eatre n\u00e9gatifs, auquel cas on utilise le fait que \\(5 \\\\times (-6)= - (5 \\\\times 6)\\) . 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat \" ) }} Exercice 03.2 \u25a1 Exercice 03.2 \u00c9nonc\u00e9 Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Exercice 04.1 \u25a1 Exercice 04.1 \u00c9nonc\u00e9 \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne ([ 1 ]) == 1 assert moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] == 4 assert moyenne ([ 1 , 2 ]) == 1.5 Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \" ) }} Exercice 04.2 \u25a1 Exercice 04.2 \u00c9nonc\u00e9 Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide. L'algorithme est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient False en renvoyant False,1 , False,2 et False,3 . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ... : return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ... : return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if tab = []: return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ( x > tab [ - 1 ]): return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Exercice 05.1 \u25a1 Exercice 05.1 \u00c9nonc\u00e9 On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau [1, 0, 1, 0, 0, 1, 1] repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est 2**6 + 2**4 + 2**1 + 2**0 = 83 . \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : def convertir ( T ): \"\"\" T est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau T \"\"\" Exemple : >>> convertir ([ 1 , 0 , 1 , 0 , 0 , 1 , 1 ]) 83 >>> convertir ([ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ]) 130 Correction {{ correction(True, \" 1 2 3 4 5 6 7 def convertir ( T ): puissance = 0 total = 0 for i in range ( len ( T ) - 1 , - 1 , - 1 ): total += T [ i ] * ( 2 ** puissance ) puissance += 1 return total \" ) }} Exercice 05.2 \u25a1 Exercice 05.2 \u00c9nonc\u00e9 La fonction tri_insertion suivante prend en argument une liste L et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if ... : return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > ... : i = ... # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , ... ): L [ k ] = L [ ... ] L [ i ] = ... return L Exemples : >>> tri_insertion ([ 2 , 5 , - 1 , 7 , 0 , 28 ]) [ - 1 , 0 , 2 , 5 , 7 , 28 ] >>> tri_insertion ([ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if L == []: return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > e : i = i - 1 # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , - 1 ): L [ k ] = L [ k - 1 ] L [ i ] = e return L \" ) }} Exercice 06.1 \u25a1 Exercice 06.1 \u00c9nonc\u00e9 On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e rendu dont le param\u00e8tre est un entier positif non nul somme_a_rendre et qui retourne une liste de trois entiers n1 , n2 et n3 qui correspondent aux nombres de billets de 5 euros ( n1 ) de pi\u00e8ces de 2 euros ( n2 ) et de pi\u00e8ces de 1 euro ( n3 ) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 somme_a_rendre . On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : >>> rendu ( 13 ) [ 2 , 1 , 1 ] >>> rendu ( 64 ) [ 12 , 2 , 0 ] >>> rendu ( 89 ) [ 17 , 2 , 0 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 def rendu ( somme_a_rendre ): pieces = [ 5 , 2 , 1 ] retour = [ 0 , 0 , 0 ] reste_a_rendre = somme_a_rendre for i in range ( 3 ): retour [ i ] = reste_a_rendre // pieces [ i ] reste_a_rendre = reste_a_rendre % pieces [ i ] return retour \" ) }} Exercice 06.2 \u25a1 \u00e0 noter une erreur dans la version officielle, sur la m\u00e9thode enfile() Exercice 06.2 \u00c9nonc\u00e9 On veut \u00e9crire une classe pour g\u00e9rer une file \u00e0 l\u2019aide d\u2019une liste cha\u00een\u00e9e. On dispose d\u2019une classe Maillon permettant la cr\u00e9ation d\u2019un maillon de la cha\u00eene, celui-ci \u00e9tant constitu\u00e9 d\u2019une valeur et d\u2019une r\u00e9f\u00e9rence au maillon suivant de la cha\u00eene : 1 2 3 4 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None Compl\u00e9ter la classe File suivante o\u00f9 l\u2019attribut dernier_file contient le maillon correspondant \u00e0 l\u2019\u00e9l\u00e9ment arriv\u00e9 en dernier dans la file : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( ... ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = ... def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != ... : print ( maillon . valeur ) maillon = ... def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = ... while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = ... maillon . suivant = None return resultat return None On pourra tester le fonctionnement de la classe en utilisant les commandes suivantes dans la console Python : >>> F = File () >>> F . est_vide () True >>> F . enfile ( 2 ) >>> F . affiche () 2 >>> F . est_vide () False >>> F . enfile ( 5 ) >>> F . enfile ( 7 ) >>> F . affiche () 7 5 2 >>> F . defile () 2 >>> F . defile () 5 >>> F . affiche () 7 Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( element ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = nouveau_maillon def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != None : print ( maillon . valeur ) maillon = maillon . suivant def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = self . dernier_file while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = maillon . suivant . valeur maillon . suivant = None return resultat return None \" ) }} Exercice 07.1 \u25a1 Exercice 07.1 \u00c9nonc\u00e9 On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par U1 = 1 , U2 = 1 et, pour tout entier naturel n , par Un+2 = Un+1 + Un . Elle s\u2019appelle la suite de Fibonacci. \u00c9crire la fonction fibonacci qui prend un entier n > 0 et qui renvoie l\u2019\u00e9l\u00e9ment d\u2019indice n de cette suite. On utilisera une programmation dynamique (pas de r\u00e9cursivit\u00e9). Exemple : >>> fibonacci ( 1 ) 1 >>> fibonacci ( 2 ) 1 >>> fibonacci ( 25 ) 75025 >>> fibonacci ( 45 ) 1134903170 Correction {{ correction(True, \" On utilise un dictionnaire pour stocker au fur et \u00e0 mesure les valeurs. 1 2 3 4 5 6 7 def fibonnaci ( n ): d = {} d [ 1 ] = 1 d [ 2 ] = 1 for k in range ( 3 , n + 1 ): d [ k ] = d [ k - 1 ] + d [ k - 2 ] return d [ n ] \" ) }} Exercice 07.2 \u25a1 Exercice 07.2 \u00c9nonc\u00e9 Les variables liste_eleves et liste_notes ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction meilleures_notes renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction meilleures_notes ci-dessous. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range ( ... ): if liste_notes [ compteur ] == ... : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ ... ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = ... liste_maxi = [ ... ] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Une fois compl\u00e9t\u00e9, le code ci-dessus donne >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = 0 liste_maxi = [] for compteur in range ( len ( liste_eleves )): if liste_notes [ compteur ] == note_maxi : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ compteur ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = 1 liste_maxi = [ liste_eleves [ compteur ]] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) \" ) }} Exercice 08.1 \ud83d\uddf9 Exercice 08.1 \u00c9nonc\u00e9 \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 Correction {{ correction(True, \" 1 2 3 4 5 6 def recherche ( caractere , mot ): somme = 0 for lettre in mot : if lettre == caractere : somme += 1 return somme \" ) }} Exercice 08.2 \u25a1 Exercice 08.2 \u00c9nonc\u00e9 On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets - le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] - (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre), on cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) On devra obtenir : >>> rendu_glouton ( 68 ,[], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton ( 291 ,[], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return solution p = pieces [ i ] if p <= arendre : solution . append ( p ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , i + 1 ) \" ) }} Exercice 09.1 \u25a1 Exercice 09.1 \u00c9nonc\u00e9 Soit le couple ( note , coefficient ): note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples ( note , coefficient ). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer le r\u00e9sultat du calcul suivant : \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): somme_notes = 0 somme_coeffs = 0 for devoir in tab : note = devoir [ 0 ] coeff = devoir [ 1 ] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs \" ) }} Exercice 09.2 \u25a1 Exercice 09.2 \u00c9nonc\u00e9 On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : Compl\u00e9ter la fonction pascal ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne 1 \u00e0 la ligne n o\u00f9 n est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 2 (le tableau sera contenu dans la variable C ). La variable Ck doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro k , la k -i\u00e8me ligne du tableau. 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , ... ): Ck = [ ... ] for i in range ( 1 , k ): Ck . append ( C [ ... ][ i - 1 ] + C [ ... ][ ... ] ) Ck . append ( ... ) C . append ( Ck ) return C Pour n = 4 , voici ce qu'on devra obtenir : >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , n + 1 ): Ck = [ 1 ] for i in range ( 1 , k ): Ck . append ( C [ k - 1 ][ i - 1 ] + C [ k - 1 ][ i ] ) Ck . append ( 1 ) C . append ( Ck ) return C \" ) }} Exercice 10.1 \ud83d\uddf9 Exercice 10.1 \u00c9nonc\u00e9 \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max ) \" ) }} Exercice 10.2 \ud83d\uddf9 Exercice 10.2 \u00c9nonc\u00e9 Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type list ). On rappelle que l\u2019expression T1 = list(T) fait une copie de T ind\u00e9pendante de T , que l\u2019expression x = T.pop() enl\u00e8ve le sommet de la pile T et le place dans la variable x et, enfin, que l\u2019expression T.append(v) place la valeur v au sommet de la pile T . Compl\u00e9ter le code Python de la fonction positif ci-dessous qui prend une pile T de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable T . 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = ... ( T ) T3 = ... while T2 != []: x = ... if ... >= 0 : T3 . append ( ... ) T2 = [] while T3 != ... : x = T3 . pop () ... print ( 'T = ' , T ) return T2 Exemple : >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) T = [ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ] [ 0 , 5 , 4 , 10 , 9 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = list ( T ) T3 = [] while T2 != []: x = T2 . pop () if x >= 0 : T3 . append ( x ) T2 = [] # <- NB : cette ligne est inutile while T3 != []: x = T3 . pop () T2 . append ( x ) print ( 'T = ' , T ) return T2 \" ) }} Exercice 11.1 \u25a1 Exercice 11.1 \u00c9nonc\u00e9 \u00c9crire une fonction conv_bin qui prend en param\u00e8tre un entier positif n et renvoie un couple ( b,bit) o\u00f9 : b est une liste d'entiers correspondant \u00e0 la repr\u00e9sentation binaire de n ; bit correspond aux nombre de bits qui constituent b . Exemple : >>> conv_bin ( 9 ) ([ 1 , 0 , 0 , 1 ], 4 ) Aide : l'op\u00e9rateur // donne le quotient de la division euclidienne : 5//2 donne 2 ; l'op\u00e9rateur % donne le reste de la division euclidienne : 5%2 donne 1 ; append est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit T=[5,2,4] , alors T.append(10) ajoute 10 \u00e0 la liste T . Ainsi, T devient [5,2,4,10] . reverse est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit T=[5,2,4,10] . Apr\u00e8s T.reverse() , la liste devient [10,4,2,5] . On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier n en partant de la gauche en appliquant successivement les instructions : b = n%2 n = n//2 r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 def conv_bin ( n ): b = [] bits = 0 while n != 0 : b . append ( n % 2 ) bits += 1 n = n // 2 b . reverse () return ( b , bits ) \" ) }} Exercice 11.2 \u25a1 Exercice 11.2 \u00c9nonc\u00e9 La fonction tri_bulles prend en param\u00e8tre une liste T d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles . 1 2 3 4 5 6 7 8 9 def tri_bulles ( T ): n = len ( T ) for i in range ( ... , ... , - 1 ): for j in range ( i ): if T [ j ] > T [ ... ]: ... = T [ j ] T [ j ] = T [ ... ] T [ j + 1 ] = temp return T \u00c9crire une autre version de l\u2019algorithme avec for i in range ( n - 1 ): en lieu et place de la troisi\u00e8me ligne du code pr\u00e9c\u00e9dent. Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def tri_bulles ( T ): n = len ( T ) for i in range ( n - 1 , 0 , - 1 ): for j in range ( i ): if T [ j ] > T [ j + 1 ]: temp = T [ j ] T [ j ] = T [ j + 1 ] T [ j + 1 ] = temp return T #version 2 def tri_bulles ( T ): n = len ( T ) for i in range ( n - 1 ): for j in range ( n - 1 , i , - 1 ): if T [ j ] < T [ j - 1 ]: temp = T [ j ] T [ j ] = T [ j - 1 ] T [ j - 1 ] = temp return T \" ) }} Exercice 12.1 \u25a1 Ce sujet est le m\u00eame que le 10.1... \u00af\\_(\u30c4)_/\u00af Exercice 12.1 \u00c9nonc\u00e9 \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max ) \" ) }} Exercice 12.2 \ud83d\uddf9 Exercice 12.2 \u00c9nonc\u00e9 La fonction recherche prend en param\u00e8tres deux chaines de caract\u00e8res gene et seq_adn et renvoie True si on retrouve gene dans seq_adn et False sinon. Compl\u00e9ter le code Python ci-dessous pour qu\u2019il impl\u00e9mente la fonction recherche . 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = ... trouve = False while i < ... and trouve == ... : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: ... if j == g : trouve = True ... return trouve Exemples : >>> recherche ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> recherche ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = 0 trouve = False while i < n - g and trouve == False : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: j += 1 if j == g : trouve = True i += 1 return trouve \" ) }} Exercice 13.1 \u25a1 Exercice 13.1 \u00c9nonc\u00e9 \u00c9crire une fonction tri_selection qui prend en param\u00e8tre une liste tab de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : >>> tri_selection ([ 1 , 52 , 6 , - 9 , 12 ]) [ - 9 , 1 , 6 , 12 , 52 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 def tri_selection ( tab ): for i in range ( len ( tab ) - 1 ): indice_min = i for j in range ( i + 1 , len ( tab )): if tab [ j ] < tab [ indice_min ]: indice_min = j tab [ i ], tab [ indice_min ] = tab [ indice_min ], tab [ i ] return tab \" ) }} Exercice 13.2 \u25a1 Exercice 13.2 \u00c9nonc\u00e9 Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction randint est utilis\u00e9e. Si a et b sont des entiers, randint(a,b) renvoie un nombre entier compris entre a et b . Compl\u00e9ter le code ci-dessous et le tester : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , ... ) nb_test = int ( input ( \"Proposez un nombre entre 1 et 99 : \" )) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test : nb_test = int ( input ( \"Trop petit ! Testez encore : \" )) else : nb_test = int ( input ( \"Trop grand ! Testez encore : \" )) if nb_mystere == nb_test : print ( \"Bravo ! Le nombre \u00e9tait \" , ... ) print ( \"Nombre d'essais: \" , ... ) else : print ( \"Perdu ! Le nombre \u00e9tait \" , ... ) Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , 100 ) nb_test = int ( input ( 'Proposez un nombre entre 1 et 99 : ' )) compteur = 0 while nb_mystere != nb_test and compteur < 10 : compteur = compteur + 1 if nb_mystere > nb_test : nb_test = int ( input ( 'Trop petit ! Testez encore : ' )) else : nb_test = int ( input ( 'Trop grand ! Testez encore : ' )) if nb_mystere == nb_test : print ( 'Bravo ! Le nombre \u00e9tait ' , nb_mystere ) print ( 'Nombre d essais: ' , compteur ) else : print ( 'Perdu ! Le nombre \u00e9tait ' , nb_mystere ) \" ) }} Exercice 14.1 \u25a1 Exercice 14.1 \u00c9nonc\u00e9 \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre et tab un tableau de nombres, et qui renvoie le tableau des indices de elt dans tab si elt est dans tab et le tableau vide [] sinon. Exemples : >>> recherche ( 3 , [ 3 , 2 , 1 , 3 , 2 , 1 ]) [ 0 , 3 ] >>> recherche ( 4 , [ 1 , 2 , 3 ]) [] Correction {{ correction(True, \" 1 2 3 4 5 6 def recherche ( elt , tab ): tab_indices = [] for i in range ( len ( tab )): if tab [ i ] == elt : tab_indices . append ( i ) return tab_indices \" ) }} Exercice 14.2 \u25a1 Exercice 14.2 \u00c9nonc\u00e9 Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : les clefs sont les noms des \u00e9l\u00e8ves ; les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients. Avec : resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ces \u00e9l\u00e8ves et lui renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom ): if nom in ... : notes = resultats [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} def moyenne ( nom ): if nom in resultats : notes = resultats [ nom ] total_points = 0 total_coefficients = 0 for valeurs in notes . values (): note , coefficient = valeurs total_points = total_points + note * coefficient total_coefficients = total_coefficients + coefficient return round ( total_points / total_coefficients , 1 ) else : return - 1 \" ) }} Exercice 15.1 \u25a1 Exercice 15.1 \u00c9nonc\u00e9 \u00c9crire une fonction rechercheMinMax qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s tab , et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> tableau = [ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : - 2 , 'max' : 9 } >>> tableau = [] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : None , 'max' : None } Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 def rechercheMinMax ( tab ): d = {} d [ 'min' ] = None d [ 'max' ] = None for val in tab : if val < d [ 'min' ]: d [ 'min' ] = val if val > d [ 'max' ]: d [ 'max' ] = val return d \" ) }} Exercice 15.2 \u25a1 Exercice 15.2 \u00c9nonc\u00e9 On dispose d\u2019un programme permettant de cr\u00e9er un objet de type PaquetDeCarte , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par #A compl\u00e9ter , puis ajouter des assertions dans l\u2019initialiseur de Carte , ainsi que dans la m\u00e9thode getCarteAt() . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): #A compl\u00e9ter \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): #A compl\u00e9ter Exemple : >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) Correction Attention, le code propos\u00e9 ne respecte pas les standards de notation : il ne faut pas de majuscules sur les noms des attributs la docstring se place \u00e0 l'int\u00e9rieur de la fonction et non au dessus. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): assert c in range ( 1 , 5 ) assert v in range ( 1 , 14 ) self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): for nb_coul in range ( 1 , 5 ): for val in range ( 1 , 14 ): self . contenu . append ( Carte ( nb_coul , val )) \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): assert pos in range ( 56 ) return self . contenu [ pos ] Exercice 16.1 \u25a1 Exercice 16.1 \u00c9nonc\u00e9 \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 Correction {{ correction(True, \" 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) \" ) }} Exercice 16.2 \u25a1 Exercice 16.2 \u00c9nonc\u00e9 On consid\u00e8re la fonction dec_to_bin ci-dessous qui prend en param\u00e8tre un entier positif a en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = ... a = a // 2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter la fonction dec_to_bin . Exemples : >>> dec_to_bin ( 83 ) '1010011' >>> dec_to_bin ( 127 ) '1111111' Correction {{ correction(True, \" 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = '' a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a \" ) }} Exercice 17.1 \u25a1 Exercice 17.1 \u00c9nonc\u00e9 \u00c9crire une fonction indice_du_min qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> indice_du_min ([ 5 ]) 0 >>> indice_du_min ([ 2 , 4 , 1 ]) 2 >>> indice_du_min ([ 5 , 3 , 2 , 2 , 4 ]) 2 Correction {{ correction(True, \" 1 2 3 4 5 6 def indice_du_min ( tab ): indice_min = 0 for i in range ( len ( tab )): if tab [ i ] < tab [ indice_min ]: indice_min = i return indice_min \" ) }} Exercice 17.2 \u25a1 Exercice 17.2 \u00c9nonc\u00e9 On consid\u00e8re la fonction separe ci-dessous qui prend en argument un tableau tab dont les \u00e9l\u00e9ments sont des 0 et des 1 et qui s\u00e9pare les 0 des 1 en pla\u00e7ant les 0 en d\u00e9but de tableau et les 1 \u00e0 la suite. 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = ... while i < j : if tab [ i ] == 0 : i = ... else : tab [ i ], tab [ j ] = ... j = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = len ( tab ) - 1 while i < j : if tab [ i ] == 0 : i = i + 1 else : tab [ i ], tab [ j ] = tab [ j ], tab [ i ] j = j - 1 return tab \" ) }} Exercice 18.1 \u25a1 Exercice 18.1 \u00c9nonc\u00e9 \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 Correction {{ correction(True, \" 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab )): if tab [ i ] == elt : return i return - 1 \" ) }} Exercice 18.2 \u25a1 Exercice 18.2 \u00c9nonc\u00e9 On consid\u00e8re la fonction insere ci-dessous qui prend en argument un entier a et un tableau tab d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur a dans le tableau et renvoie le nouveau tableau. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes python. Sujet l\u00e9g\u00e8rement modifi\u00e9 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = ... while a < ... and i >= ... : l [ i + 1 ] = ... l [ i ] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : >>> insere ( 3 ,[ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 10 ,[ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 10 , 12 , 14 , 25 ] >>> insere ( 1 ,[ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = len ( l ) - 2 while a < l [ i ] and i >= 0 : l [ i + 1 ] = l [ i ] l [ i ] = a i = i - 1 return l \" ) }} Exercice 19.1 \u25a1 Exercice 19.1 \u00c9nonc\u00e9 \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, -1 sinon. Exemples : >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1 \" ) }} Exercice 19.2 \u25a1 Exercice 19.2 \u00c9nonc\u00e9 Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve et -1 sinon. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for ... in message : if lettre in ALPHABET : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for lettre in message : if lettre in ALPHABET : indice = ( position_alphabet ( lettre ) + decalage ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = resultat + lettre return resultat \" ) }} Exercice 20.1 \ud83d\uddf9 Exercice 20.1 \u00c9nonc\u00e9 On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] \u00c9crire la fonction mini qui prend en param\u00e8tres le tableau releve des relev\u00e9s et le tableau date des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. Exemple : >>> mini ( t_moy , annees ) ( 12.5 , 2016 ) Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] def mini ( releve , date ): temp_mini = releve [ 0 ] date_mini = date [ 0 ] for i in range ( len ( releve )): if releve [ i ] < temp_mini : temp_mini = releve [ i ] date_mini = date [ i ] return temp_mini , date_mini \" ) }} Exercice 20.2 \ud83d\uddf9 Exercice 20.2 \u00c9nonc\u00e9 Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : bob , radar , et non sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction est_nbre_palindrome s\u2019appuiera sur la fonction est_palindrome qui elle-m\u00eame s\u2019appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res chaine et renvoie la cha\u00eene invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbre_palindrome teste si un nombre nbre est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. def inverse_chaine ( chaine ): result = ... for caractere in chaine : result = ... return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return ... def est_nbre_palindrome ( nbre ): chaine = ... return est_palindrome ( chaine ) Exemples : >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 def inverse_chaine ( chaine ): result = '' for caractere in chaine : result = caractere + result return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return chaine == inverse def est_nbre_palindrome ( nbre ): chaine = str ( nbre ) return est_palindrome ( chaine ) \" ) }} Exercice 21.1 \u25a1 Exercice 21.1 \u00c9nonc\u00e9 \u00c9crire une fonction python appel\u00e9e nb_repetitions qui prend en param\u00e8tres un \u00e9l\u00e9ment elt et une liste tab et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : >>> nb_repetitions ( 5 ,[ 2 , 5 , 3 , 5 , 6 , 9 , 5 ]) 3 >>> nb_repetitions ( 'A' ,[ 'B' , 'A' , 'B' , 'A' , 'R' ]) 2 >>> nb_repetitions ( 12 ,[ 1 , '! ' , 7 , 21 , 36 , 44 ]) 0 Correction {{ correction(True, \" 1 2 3 4 5 6 def nb_repetitions ( elt , tab ): nb = 0 for element in tab : if element == elt : nb += 1 return nb \" ) }} Exercice 21.2 \u25a1 Exercice 21.2 \u00c9nonc\u00e9 Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( ... ) a = a // 2 while a ... : bin_a = ... ( a % 2 ) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' Correction {{ correction(True, \" 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a \" ) }} Exercice 22.1 \u25a1 Exercice 22.1 \u00c9nonc\u00e9 \u00c9crire en langage Python une fonction recherche prenant comme param\u00e8tres une variable a de type num\u00e9rique ( float ou int ) et un tableau t (type list ) et qui renvoie le nombre d'occurrences de a dans t . Exemples : >>> recherche ( 5 ,[]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 4 , 8 ]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 1 , 5 , 3 , 7 , 4 ]) 1 >>> recherche ( 5 ,[ - 2 , 5 , 3 , 5 , 4 , 5 ]) 3 Correction {{ correction(True, \" 1 2 3 4 5 6 def recherche ( a , t ): nb = 0 for element in t : if element == a : nb += 1 return nb \" ) }} Exercice 22.2 \u25a1 Exercice 22.2 \u00c9nonc\u00e9 La fonction rendu_monnaie_centimes prend en param\u00e8tres deux nombres entiers positifs s_due et s_versee et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence s_versee \u2013 s_due pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. La fonction renvoie la liste des pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en centimes d\u2019euros. Les valeurs possibles pour les pi\u00e8ces sont donc [1, 2, 5, 10, 20, 50, 100, 200] . Ainsi, l\u2019instruction rendu_monnaie_centimes(452, 500) renverra [20, 20, 5, 2, 1] . En effet, la somme \u00e0 rendre est de 48 centimes soit 20 + 20 + 5 + 2 + 1 . Le code de la fonction est donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = ... a_rendre = ... i = len ( pieces ) - 1 while a_rendre > ... : if pieces [ i ] <= a_rendre : rendu . append ( ... ) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code pour qu'il donne : >>> rendu_monnaie_centimes ( 700 , 700 ) [] >>> rendu_monnaie_centimes ( 112 , 500 ) [ 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = [] a_rendre = s_versee - s_due i = len ( pieces ) - 1 while a_rendre > 0 : if pieces [ i ] <= a_rendre : rendu . append ( pieces [ i ]) a_rendre = a_rendre - pieces [ i ] else : i = i - 1 return rendu \" ) }} Exercice 23.1 \u25a1 Exercice 23.1 \u00c9nonc\u00e9 L\u2019occurrence d\u2019un caract\u00e8re dans un phrase est le nombre de fois o\u00f9 ce caract\u00e8re est pr\u00e9sent. Exemples : l\u2019occurrence du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; l\u2019occurrence du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : {'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1} \u00c9crire une fonction occurence_lettres prenant comme param\u00e8tre une variable phrase de type str . Cette fonction doit renvoyer un dictionnaire de type constitu\u00e9 des occurrences des caract\u00e8res pr\u00e9sents dans la phrase. Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 def occurence_lettres ( phrase ): occ = {} for caractere in phrase : if caractere in occ : occ [ caractere ] += 1 else : occ [ caractere ] = 1 return occ \" ) }} Exercice 23.2 \u25a1 Exercice 23.2 \u00c9nonc\u00e9 La fonction fusion prend deux listes L1 , L2 d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e L12 qu\u2019elle renvoie. Le code Python de la fonction est 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = ... i1 = ... else : L12 [ i ] = L2 [ i2 ] i2 = ... i += 1 while i1 < n1 : L12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : L12 [ i ] = ... i2 = i2 + 1 i = ... return L12 Compl\u00e9ter le code. Exemple : >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and i2 < n2 : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 else : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i += 1 while i1 < n1 : L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 i = i + 1 while i2 < n2 : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i = i + 1 return L12 \" ) }} Exercice 24.1 \u25a1 identique au 18.1 Exercice 24.1 \u00c9nonc\u00e9 \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1 \" ) }} Exercice 24.2 \u25a1 Exercice 24.2 \u00c9nonc\u00e9 On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de 192.168.0.0 \u00e0 192.168.0.255 . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP 192.168.0.0 et 192.168.0.255 sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe AdresseIP . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class AdresseIP : def __init__ ( self , adresse ): self . adresse = ... def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254 : octet_nouveau = ... + ... return AdresseIP ( '192.168.0.' + ... ) else : return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class AdresseIP : def __init__ ( self , adresse ): self . adresse = adresse def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return self . liste_octet ()[ 3 ] == 0 or self . liste_octet ()[ 3 ] == 255 def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if self . liste_octet ()[ 3 ] < 254 : octet_nouveau = self . liste_octet ()[ 3 ] + 1 return AdresseIP ( '192.168.0.' + str ( octet_nouveau )) else : return False adresse1 = AdresseIP ( '192.168.0.1' ) adresse2 = AdresseIP ( '192.168.0.2' ) adresse3 = AdresseIP ( '192.168.0.0' ) Exercice 25.1 \u25a1 Exercice 25.1 \u00c9nonc\u00e9 \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] Correction {{ correction(True, \" 1 2 3 4 5 6 def recherche ( tab ): solution = [] for i in range ( len ( tab ) - 1 ): if tab [ i ] + 1 == tab [ i + 1 ]: solution . append (( tab [ i ], tab [ i + 1 ])) return solution \" ) }} Exercice 25.2 \u25a1 Exercice 25.2 \u00c9nonc\u00e9 Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M , deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M,2,1,3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == ... ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( ... ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , ... , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( ... ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , ... , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( ... ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , ... , val ) Exemple : >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == 0 : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == 1 ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( i + 1 ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , i + 1 , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( j - 1 ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , j - 1 , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( j + 1 ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , j + 1 , val ) \" ) }} Exercice 26.1 \u25a1 Exercice 26.1 \u00c9nonc\u00e9 \u00c9crire une fonction occurrence_max prenant en param\u00e8tres une cha\u00eene de caract\u00e8res chaine et qui renvoie le caract\u00e8re le plus fr\u00e9quent de la cha\u00eene. La chaine ne contient que des lettres en minuscules sans accent. On pourra s\u2019aider du tableau alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o,','p','q','r','s','t','u','v','w','x','y','z'] et du tableau occurrence de 26 \u00e9l\u00e9ments o\u00f9 l\u2019on mettra dans occurrence[i] le nombre d\u2019apparitions de alphabet[i] dans la chaine. Puis on calculera l\u2019indice k d\u2019un maximum du tableau occurrence et on affichera alphabet[k] . Exemple : >>> ch = 'je suis en terminale et je passe le bac et je souhaite poursuivre des etudes pour devenir expert en informatique' >>> occurrence_max ( ch ) \u2018 e \u2019 Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 alphabet = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o,' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' ] def occurrence_max ( chaine ): occurence = [ 0 ] * 26 for i in range ( 26 ): compteur = 0 for caractere in chaine : if caractere == alphabet [ i ]: compteur += 1 occurence [ i ] = compteur ind_max = 0 for i in range ( 26 ): if occurence [ i ] > occurence [ ind_max ]: ind_max = i return alphabet [ ind_max ] \" ) }} Exercice 26.2 \u25a1 Exercice 26.2 \u00c9nonc\u00e9 On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Compl\u00e9ter le programme ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return ... def nbCol ( image ): '''renvoie la largeur de l'image''' return ... def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): L [ i ][ j ] = ... return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): if image [ i ][ j ] < ... : L [ i ][ j ] = ... else : L [ i ][ j ] = ... return L Exemple : >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 287 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , - 32 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( negatif ( img ), 120 ) [[ 1 , 1 , 0 , 0 , 1 ], [ 1 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 ], [ 0 , 1 , 1 , 0 , 0 ]] Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return len ( image ) def nbCol ( image ): '''renvoie la largeur de l'image''' return len ( image [ 0 ]) def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): L [ i ][ j ] = 255 - image [ i ][ j ] return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): if image [ i ][ j ] < seuil : L [ i ][ j ] = 0 else : L [ i ][ j ] = 1 return L Exercice 27.1 \u25a1 Exercice 27.1 \u00c9nonc\u00e9 \u00c9crire une fonction moyenne prenant en param\u00e8tres une liste d\u2019entiers et qui renvoie la moyenne des valeurs de cette liste. Exemple : >>> moyenne ([ 10 , 20 , 30 , 40 , 60 , 110 ]) 45.0 Correction {{ correction(True, \" 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) \" ) }} Exercice 27.2 \u25a1 Exercice 27.2 \u00c9nonc\u00e9 On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction affiche permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction zoomListe prend en argument une liste liste_depart et un entier k . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de liste_depart est dupliqu\u00e9 k fois. La fonction zoomDessin prend en argument la grille dessin et renvoie une grille o\u00f9 toutes les lignes de dessin sont zoom\u00e9es k fois et r\u00e9p\u00e9t\u00e9es k fois. Soit le code ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin : for col in ligne : if col == 1 : print ( \" *\" , end = \"\" ) else : print ( \" \" , end = \"\" ) print () def zoomListe ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range ( k ): ... return liste_zoom def zoomDessin ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom = [] for elt in grille : liste_zoom = ... for i in range ( k ): ... . append ( ... ) return grille_zoom R\u00e9sultats \u00e0 obtenir : >>> affiche ( coeur ) >>> affiche ( zoomDessin ( coeur , 3 )) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): for ligne in dessin : for col in ligne : if col == 1 : print ( ' *' , end = '' ) else : print ( ' ' , end = '' ) print () def zoomListe ( liste_depart , k ): liste_zoom = [] for elt in liste_depart : for i in range ( k ): liste_zoom . append ( elt ) return liste_zoom def zoomDessin ( grille , k ): grille_zoom = [] for elt in grille : liste_zoom = zoomListe ( elt , k ) for i in range ( k ): grille_zoom . append ( liste_zoom ) return grille_zoom Exercice 28.1 \u25a1 Exercice 28.1 \u00c9nonc\u00e9 Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre est stock\u00e9 dans a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], \\ 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], \\ 'H' :[ '' , '' ]} \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tres un arbre binaire arbre sous la forme d\u2019un dictionnaire et un caract\u00e8re lettre qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153ud. On pourra distinguer les 4 cas o\u00f9 les deux \u00ab fils \u00bb du n\u0153ud sont '' , le fils gauche seulement est '' , le fils droit seulement est '' , aucun des deux fils n\u2019est '' . Exemple : >>> taille ( a , \u2019 F \u2019 ) 9 Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], 'H' :[ '' , '' ]} def taille ( arbre , lettre ): fils_gauche = arbre [ lettre ][ 0 ] fils_droit = arbre [ lettre ][ 1 ] if fils_gauche != '' and fils_droit != '' : return 1 + taille ( arbre , fils_gauche ) + taille ( arbre , fils_droit ) if fils_gauche != '' and fils_droit == '' : return 1 + taille ( arbre , fils_gauche ) if fils_gauche == '' and fils_droit != '' : return 1 + taille ( arbre , fils_droit ) else : return 1 \" ) }} Exercice 28.2 \u25a1 Exercice 28.2 \u00c9nonc\u00e9 On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt depuis le d\u00e9but du tableau tous les \u00e9l\u00e9ments non rang\u00e9s et on place en derni\u00e8re position le plus grand \u00e9l\u00e9ment. Exemple avec le tableau : t = [41, 55, 21, 18, 12, 6, 25] \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus grand \u00e9l\u00e9ment avec le dernier. Le tableau devient t = [41, 25, 21, 18, 12, 6, 55] \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le dernier , on permute le plus grand \u00e9l\u00e9ment trouv\u00e9 avec l'avant dernier. Le tableau devient : t = [6, 25, 21, 18, 12, 41, 55] Et ainsi de suite. La code de la fonction tri_iteratif qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( ... , 0 , - 1 ): imax = ... for i in range ( 0 , ... ): if tab [ i ] > ... : imax = i if tab [ max ] > ... : ... , tab [ imax ] = tab [ imax ], ... return tab Compl\u00e9ter le code qui doit donner : >>> tri_iteratif ([ 41 , 55 , 21 , 18 , 12 , 6 , 25 ]) [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et b . Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( len ( tab ) - 1 , 0 , - 1 ): imax = 0 for i in range ( 0 , k ): if tab [ i ] > tab [ imax ] : imax = i if tab [ imax ] > tab [ k ] : tab [ k ], tab [ imax ] = tab [ imax ], tab [ k ] return tab \" ) }} Exercice 29.1 \u25a1 Exercice 29.1 \u00c9nonc\u00e9 Soit un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 1 : s'il est pair, on le divise par 2 ; s\u2019il est impair, on le multiplie par 3 et on ajoute 1. Puis on recommence ces \u00e9tapes avec le nombre entier obtenu, jusqu\u2019\u00e0 ce que l\u2019on obtienne la valeur 1. On d\u00e9finit ainsi la suite \\((U_n)\\) par : \\(U_0=k\\) , o\u00f9 \\(k\\) est un entier choisi initialement; \\(U_{n+1} = \\dfrac{U_n}{2}\\) si \\(U_n\\) est pair; \\(U_{n+1} = 3 \\times U_n + 1\\) si \\(U_n\\) est impair. On admet que, quel que soit l'entier k choisi au d\u00e9part, la suite finit toujours sur la valeur 1. \u00c9crire une fonction calcul prenant en param\u00e8tres un entier n strictement positif et qui renvoie la liste des valeurs de la suite, en partant de n et jusqu'\u00e0 atteindre 1. Exemple : >>> calcul ( 7 ) [ 7 , 22 , 11 , 34 , 17 , 52 , 26 , 13 , 40 , 20 , 10 , 5 , 16 , 8 , 4 , 2 , 1 ] Correction {{ correction(True, \" \" ) }} Exercice 29.2 \u25a1 Exercice 29.2 \u00c9nonc\u00e9 On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction est_parfait ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res mot (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de mot , ainsi qu\u2019un bool\u00e9en qui indique si mot est parfait ou pas. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = ??? for c in mot : code_c = code_c + ??? code_a = ??? code_c = int ( code_c ) if ??? : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] Exemples : >>> est_parfait ( \"PAUL\" ) [ 50 , 1612112 , False ] >>> est_parfait ( \"ALAIN\" ) [ 37 , 1121914 , True ] Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = 0 for c in mot : code_c = code_c + str ( dico [ c ]) code_a = code_a + dico [ c ] code_c = int ( code_c ) if code_c % code_a == 0 : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] Exercice 30.1 \u25a1 Exercice 30.1 \u00c9nonc\u00e9 Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat \" ) }} Exercice 30.2 \u25a1 Exercice 30.2 \u00c9nonc\u00e9 Soit T un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et n un entier. La fonction chercher , donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur n appara\u00eet \u00e9ventuellement dans T , et None sinon. Les param\u00e8tres de la fonction sont : T , le tableau dans lequel s'effectue la recherche ; n , l'entier \u00e0 chercher dans le tableau ; i , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; j , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction chercher est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si 0 <= i et j < len(T) . Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche \"Erreur\" puis renvoie None . Recopier et compl\u00e9ter le code de la fonction chercher propos\u00e9e ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or ??? : print ( \"Erreur\" ) return None if i > j : return None m = ( i + j ) // ??? if T [ m ] < ??? : return chercher ( T , n , ??? , ??? ) elif ??? : return chercher ( T , n , ??? , ??? ) else : return ??? L'ex\u00e9cution du code doit donner : >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) Erreur >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or j >= len ( T ) : print ( 'Erreur' ) return None if i > j : return None m = ( i + j ) // 2 if T [ m ] < n : return chercher ( T , n , m + 1 , j ) elif T [ m ] > n : return chercher ( T , n , i , m - 1 ) else : return m \" ) }} Sources en Markdown Soit `T` un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et `n` un entier. La fonction `chercher`, donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur `n` appara\u00eet \u00e9ventuellement dans `T`, et `None` sinon. Les param\u00e8tres de la fonction sont : - `T`, le tableau dans lequel s'effectue la recherche ; - `n`, l'entier \u00e0 chercher dans le tableau ; - `i`, l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; - `j`, l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction `chercher` est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si `0 <= i` et `j < len(T)`. Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche `\"Erreur\"` puis renvoie `None`. Recopier et compl\u00e9ter le code de la fonction `chercher` propos\u00e9e ci-dessous : ```python linenums='1' def chercher(T, n, i, j): if i < 0 or ??? : print(\"Erreur\") return None if i > j : return None m = (i + j) // ??? if T[m] < ??? : return chercher(T, n, ??? , ???) elif ??? : return chercher(T, n, ??? , ??? ) else : return ??? ``` L'ex\u00e9cution du code doit donner : ```python >>> chercher([1,5,6,6,9,12],7,0,10) Erreur >>> chercher([1,5,6,6,9,12],7,0,5) >>> chercher([1,5,6,6,9,12],9,0,5) 4 >>> chercher([1,5,6,6,9,12],6,0,5) 2 ```","title":"EP NSI corriges"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-011","text":"Exercice 01.1 \u00c9nonc\u00e9 Programmer la fonction recherche , prenant en param\u00e8tre un tableau non vide tab (type list ) d'entiers et un entier n , et qui renvoie l'indice de la derni\u00e8re occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples >>> recherche ([ 5 , 3 ], 1 ) 2 >>> recherche ([ 2 , 4 ], 2 ) 0 >>> recherche ([ 2 , 3 , 5 , 2 , 4 ], 2 ) 3 Correction {{ correction(True, \" 1 2 3 4 5 6 def recherche ( tab , n ): indice_solution = len ( tab ) for i in range ( len ( tab )): if tab [ i ] == n : indice_solution = i return indice_solution \" ) }}","title":"Exercice 01.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-012","text":"Exercice 01.2 \u00c9nonc\u00e9 On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es \\((x;y)\\) et \\((x';y')\\) est donn\u00e9e par la formule : \\[d=\\sqrt{(x-x')^2+(y-y')^2}\\] On importe pour cela la fonction racine carr\u00e9e ( sqrt ) du module math de Python. On dispose d'une fonction distance et d'une fonction plus_courte_distance : from math import sqrt # import de la fonction racine carr\u00e9e def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( ... ) ** 2 + ( ... ) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = ... for i in range ( 1 , ... ): if distance ( tab [ i ], depart ) ... : point = ... min_dist = ... return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Recopier sous Python (sans les commentaires) ces deux fonctions puis compl\u00e9ter leur code et ajouter une ou des d\u00e9clarations ( assert ) \u00e0 la fonction distance permettant de v\u00e9rifier la ou les pr\u00e9conditions. Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from math import sqrt def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( point1 [ 0 ] - point2 [ 0 ]) ** 2 + (( point1 [ 1 ] - point2 [ 1 ])) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = distance ( point , depart ) for i in range ( 1 , len ( tab )): if distance ( tab [ i ], depart ) < min_dist : point = tab [ i ] min_dist = distance ( tab [ i ], depart ) return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\"","title":"Exercice 01.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-021","text":"Exercice 02.1 \u00c9nonc\u00e9 Programmer la fonction moyenne prenant en param\u00e8tre un tableau d'entiers tab (type list ) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide et affiche 'erreur' si le tableau est vide. Exemples : >>> moyenne ([ 5 , 3 , 8 ]) 5.333333333333333 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) 5.5 >>> moyenne ([]) 'erreur' Correction {{ correction(True, \" L'\u00e9nonc\u00e9 n'est pas tr\u00e8s clair quand il dit \u00abd'afficher 'erreur'\u00bb (ce qui suppose un print et non un return ). Nous choississons donc dans ce cas de renvoyer None . 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): if tab == []: print ( 'erreur' ) return None else : somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \" ) }}","title":"Exercice 02.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-022","text":"Exercice 02.2 \u00c9nonc\u00e9 On consid\u00e8re un tableau d'entiers tab (type list dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri,le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Zone de 0 Zone non tri\u00e9e Zone de 1 Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction tri suivante : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = ... j = ... while i != j : if tab [ i ] == 0 : i = ... else : valeur = tab [ j ] tab [ j ] = ... ... j = ... ... Exemple : >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = 0 j = len ( tab ) - 1 while i != j : if tab [ i ] == 0 : i = i + 1 else : valeur = tab [ j ] tab [ j ] = tab [ i ] tab [ i ] = valeur j = j - 1 return tab \" ) }}","title":"Exercice 02.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-031","text":"Exercice 03.1 \u00c9nonc\u00e9 Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Correction {{ correction(True, \" \u00c9nonc\u00e9 peu clair, on ne sait pas si n1 et n2 sont entiers naturels ou relatifs. Nous d\u00e9cidons qu'ils sont relatifs et donc qu'ils peuvent \u00eatre n\u00e9gatifs, auquel cas on utilise le fait que \\(5 \\\\times (-6)= - (5 \\\\times 6)\\) . 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat \" ) }}","title":"Exercice 03.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-032","text":"Exercice 03.2 \u00c9nonc\u00e9 Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False","title":"Exercice 03.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-041","text":"Exercice 04.1 \u00c9nonc\u00e9 \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne ([ 1 ]) == 1 assert moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] == 4 assert moyenne ([ 1 , 2 ]) == 1.5 Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \" ) }}","title":"Exercice 04.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-042","text":"Exercice 04.2 \u00c9nonc\u00e9 Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide. L'algorithme est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient False en renvoyant False,1 , False,2 et False,3 . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ... : return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ... : return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if tab = []: return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ( x > tab [ - 1 ]): return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False","title":"Exercice 04.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-051","text":"Exercice 05.1 \u00c9nonc\u00e9 On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau [1, 0, 1, 0, 0, 1, 1] repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est 2**6 + 2**4 + 2**1 + 2**0 = 83 . \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : def convertir ( T ): \"\"\" T est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau T \"\"\" Exemple : >>> convertir ([ 1 , 0 , 1 , 0 , 0 , 1 , 1 ]) 83 >>> convertir ([ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ]) 130 Correction {{ correction(True, \" 1 2 3 4 5 6 7 def convertir ( T ): puissance = 0 total = 0 for i in range ( len ( T ) - 1 , - 1 , - 1 ): total += T [ i ] * ( 2 ** puissance ) puissance += 1 return total \" ) }}","title":"Exercice 05.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-052","text":"Exercice 05.2 \u00c9nonc\u00e9 La fonction tri_insertion suivante prend en argument une liste L et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if ... : return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > ... : i = ... # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , ... ): L [ k ] = L [ ... ] L [ i ] = ... return L Exemples : >>> tri_insertion ([ 2 , 5 , - 1 , 7 , 0 , 28 ]) [ - 1 , 0 , 2 , 5 , 7 , 28 ] >>> tri_insertion ([ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if L == []: return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > e : i = i - 1 # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , - 1 ): L [ k ] = L [ k - 1 ] L [ i ] = e return L \" ) }}","title":"Exercice 05.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-061","text":"Exercice 06.1 \u00c9nonc\u00e9 On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e rendu dont le param\u00e8tre est un entier positif non nul somme_a_rendre et qui retourne une liste de trois entiers n1 , n2 et n3 qui correspondent aux nombres de billets de 5 euros ( n1 ) de pi\u00e8ces de 2 euros ( n2 ) et de pi\u00e8ces de 1 euro ( n3 ) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 somme_a_rendre . On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : >>> rendu ( 13 ) [ 2 , 1 , 1 ] >>> rendu ( 64 ) [ 12 , 2 , 0 ] >>> rendu ( 89 ) [ 17 , 2 , 0 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 def rendu ( somme_a_rendre ): pieces = [ 5 , 2 , 1 ] retour = [ 0 , 0 , 0 ] reste_a_rendre = somme_a_rendre for i in range ( 3 ): retour [ i ] = reste_a_rendre // pieces [ i ] reste_a_rendre = reste_a_rendre % pieces [ i ] return retour \" ) }}","title":"Exercice 06.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-062","text":"\u00e0 noter une erreur dans la version officielle, sur la m\u00e9thode enfile() Exercice 06.2 \u00c9nonc\u00e9 On veut \u00e9crire une classe pour g\u00e9rer une file \u00e0 l\u2019aide d\u2019une liste cha\u00een\u00e9e. On dispose d\u2019une classe Maillon permettant la cr\u00e9ation d\u2019un maillon de la cha\u00eene, celui-ci \u00e9tant constitu\u00e9 d\u2019une valeur et d\u2019une r\u00e9f\u00e9rence au maillon suivant de la cha\u00eene : 1 2 3 4 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None Compl\u00e9ter la classe File suivante o\u00f9 l\u2019attribut dernier_file contient le maillon correspondant \u00e0 l\u2019\u00e9l\u00e9ment arriv\u00e9 en dernier dans la file : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( ... ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = ... def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != ... : print ( maillon . valeur ) maillon = ... def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = ... while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = ... maillon . suivant = None return resultat return None On pourra tester le fonctionnement de la classe en utilisant les commandes suivantes dans la console Python : >>> F = File () >>> F . est_vide () True >>> F . enfile ( 2 ) >>> F . affiche () 2 >>> F . est_vide () False >>> F . enfile ( 5 ) >>> F . enfile ( 7 ) >>> F . affiche () 7 5 2 >>> F . defile () 2 >>> F . defile () 5 >>> F . affiche () 7 Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( element ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = nouveau_maillon def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != None : print ( maillon . valeur ) maillon = maillon . suivant def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = self . dernier_file while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = maillon . suivant . valeur maillon . suivant = None return resultat return None \" ) }}","title":"Exercice 06.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-071","text":"Exercice 07.1 \u00c9nonc\u00e9 On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par U1 = 1 , U2 = 1 et, pour tout entier naturel n , par Un+2 = Un+1 + Un . Elle s\u2019appelle la suite de Fibonacci. \u00c9crire la fonction fibonacci qui prend un entier n > 0 et qui renvoie l\u2019\u00e9l\u00e9ment d\u2019indice n de cette suite. On utilisera une programmation dynamique (pas de r\u00e9cursivit\u00e9). Exemple : >>> fibonacci ( 1 ) 1 >>> fibonacci ( 2 ) 1 >>> fibonacci ( 25 ) 75025 >>> fibonacci ( 45 ) 1134903170 Correction {{ correction(True, \" On utilise un dictionnaire pour stocker au fur et \u00e0 mesure les valeurs. 1 2 3 4 5 6 7 def fibonnaci ( n ): d = {} d [ 1 ] = 1 d [ 2 ] = 1 for k in range ( 3 , n + 1 ): d [ k ] = d [ k - 1 ] + d [ k - 2 ] return d [ n ] \" ) }}","title":"Exercice 07.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-072","text":"Exercice 07.2 \u00c9nonc\u00e9 Les variables liste_eleves et liste_notes ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction meilleures_notes renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction meilleures_notes ci-dessous. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range ( ... ): if liste_notes [ compteur ] == ... : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ ... ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = ... liste_maxi = [ ... ] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Une fois compl\u00e9t\u00e9, le code ci-dessus donne >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = 0 liste_maxi = [] for compteur in range ( len ( liste_eleves )): if liste_notes [ compteur ] == note_maxi : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ compteur ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = 1 liste_maxi = [ liste_eleves [ compteur ]] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) \" ) }}","title":"Exercice 07.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-081","text":"Exercice 08.1 \u00c9nonc\u00e9 \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 Correction {{ correction(True, \" 1 2 3 4 5 6 def recherche ( caractere , mot ): somme = 0 for lettre in mot : if lettre == caractere : somme += 1 return somme \" ) }}","title":"Exercice 08.1 \ud83d\uddf9"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-082","text":"Exercice 08.2 \u00c9nonc\u00e9 On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets - le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] - (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre), on cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) On devra obtenir : >>> rendu_glouton ( 68 ,[], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton ( 291 ,[], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return solution p = pieces [ i ] if p <= arendre : solution . append ( p ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , i + 1 ) \" ) }}","title":"Exercice 08.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-091","text":"Exercice 09.1 \u00c9nonc\u00e9 Soit le couple ( note , coefficient ): note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples ( note , coefficient ). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer le r\u00e9sultat du calcul suivant : \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): somme_notes = 0 somme_coeffs = 0 for devoir in tab : note = devoir [ 0 ] coeff = devoir [ 1 ] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs \" ) }}","title":"Exercice 09.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-092","text":"Exercice 09.2 \u00c9nonc\u00e9 On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : Compl\u00e9ter la fonction pascal ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne 1 \u00e0 la ligne n o\u00f9 n est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 2 (le tableau sera contenu dans la variable C ). La variable Ck doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro k , la k -i\u00e8me ligne du tableau. 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , ... ): Ck = [ ... ] for i in range ( 1 , k ): Ck . append ( C [ ... ][ i - 1 ] + C [ ... ][ ... ] ) Ck . append ( ... ) C . append ( Ck ) return C Pour n = 4 , voici ce qu'on devra obtenir : >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , n + 1 ): Ck = [ 1 ] for i in range ( 1 , k ): Ck . append ( C [ k - 1 ][ i - 1 ] + C [ k - 1 ][ i ] ) Ck . append ( 1 ) C . append ( Ck ) return C \" ) }}","title":"Exercice 09.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-101","text":"Exercice 10.1 \u00c9nonc\u00e9 \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max ) \" ) }}","title":"Exercice 10.1 \ud83d\uddf9"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-102","text":"Exercice 10.2 \u00c9nonc\u00e9 Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type list ). On rappelle que l\u2019expression T1 = list(T) fait une copie de T ind\u00e9pendante de T , que l\u2019expression x = T.pop() enl\u00e8ve le sommet de la pile T et le place dans la variable x et, enfin, que l\u2019expression T.append(v) place la valeur v au sommet de la pile T . Compl\u00e9ter le code Python de la fonction positif ci-dessous qui prend une pile T de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable T . 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = ... ( T ) T3 = ... while T2 != []: x = ... if ... >= 0 : T3 . append ( ... ) T2 = [] while T3 != ... : x = T3 . pop () ... print ( 'T = ' , T ) return T2 Exemple : >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) T = [ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ] [ 0 , 5 , 4 , 10 , 9 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = list ( T ) T3 = [] while T2 != []: x = T2 . pop () if x >= 0 : T3 . append ( x ) T2 = [] # <- NB : cette ligne est inutile while T3 != []: x = T3 . pop () T2 . append ( x ) print ( 'T = ' , T ) return T2 \" ) }}","title":"Exercice 10.2 \ud83d\uddf9"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-111","text":"Exercice 11.1 \u00c9nonc\u00e9 \u00c9crire une fonction conv_bin qui prend en param\u00e8tre un entier positif n et renvoie un couple ( b,bit) o\u00f9 : b est une liste d'entiers correspondant \u00e0 la repr\u00e9sentation binaire de n ; bit correspond aux nombre de bits qui constituent b . Exemple : >>> conv_bin ( 9 ) ([ 1 , 0 , 0 , 1 ], 4 ) Aide : l'op\u00e9rateur // donne le quotient de la division euclidienne : 5//2 donne 2 ; l'op\u00e9rateur % donne le reste de la division euclidienne : 5%2 donne 1 ; append est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit T=[5,2,4] , alors T.append(10) ajoute 10 \u00e0 la liste T . Ainsi, T devient [5,2,4,10] . reverse est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit T=[5,2,4,10] . Apr\u00e8s T.reverse() , la liste devient [10,4,2,5] . On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier n en partant de la gauche en appliquant successivement les instructions : b = n%2 n = n//2 r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 def conv_bin ( n ): b = [] bits = 0 while n != 0 : b . append ( n % 2 ) bits += 1 n = n // 2 b . reverse () return ( b , bits ) \" ) }}","title":"Exercice 11.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-112","text":"Exercice 11.2 \u00c9nonc\u00e9 La fonction tri_bulles prend en param\u00e8tre une liste T d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles . 1 2 3 4 5 6 7 8 9 def tri_bulles ( T ): n = len ( T ) for i in range ( ... , ... , - 1 ): for j in range ( i ): if T [ j ] > T [ ... ]: ... = T [ j ] T [ j ] = T [ ... ] T [ j + 1 ] = temp return T \u00c9crire une autre version de l\u2019algorithme avec for i in range ( n - 1 ): en lieu et place de la troisi\u00e8me ligne du code pr\u00e9c\u00e9dent. Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def tri_bulles ( T ): n = len ( T ) for i in range ( n - 1 , 0 , - 1 ): for j in range ( i ): if T [ j ] > T [ j + 1 ]: temp = T [ j ] T [ j ] = T [ j + 1 ] T [ j + 1 ] = temp return T #version 2 def tri_bulles ( T ): n = len ( T ) for i in range ( n - 1 ): for j in range ( n - 1 , i , - 1 ): if T [ j ] < T [ j - 1 ]: temp = T [ j ] T [ j ] = T [ j - 1 ] T [ j - 1 ] = temp return T \" ) }}","title":"Exercice 11.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-121","text":"Ce sujet est le m\u00eame que le 10.1... \u00af\\_(\u30c4)_/\u00af Exercice 12.1 \u00c9nonc\u00e9 \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max ) \" ) }}","title":"Exercice 12.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-122","text":"Exercice 12.2 \u00c9nonc\u00e9 La fonction recherche prend en param\u00e8tres deux chaines de caract\u00e8res gene et seq_adn et renvoie True si on retrouve gene dans seq_adn et False sinon. Compl\u00e9ter le code Python ci-dessous pour qu\u2019il impl\u00e9mente la fonction recherche . 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = ... trouve = False while i < ... and trouve == ... : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: ... if j == g : trouve = True ... return trouve Exemples : >>> recherche ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> recherche ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = 0 trouve = False while i < n - g and trouve == False : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: j += 1 if j == g : trouve = True i += 1 return trouve \" ) }}","title":"Exercice 12.2 \ud83d\uddf9"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-131","text":"Exercice 13.1 \u00c9nonc\u00e9 \u00c9crire une fonction tri_selection qui prend en param\u00e8tre une liste tab de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : >>> tri_selection ([ 1 , 52 , 6 , - 9 , 12 ]) [ - 9 , 1 , 6 , 12 , 52 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 def tri_selection ( tab ): for i in range ( len ( tab ) - 1 ): indice_min = i for j in range ( i + 1 , len ( tab )): if tab [ j ] < tab [ indice_min ]: indice_min = j tab [ i ], tab [ indice_min ] = tab [ indice_min ], tab [ i ] return tab \" ) }}","title":"Exercice 13.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-132","text":"Exercice 13.2 \u00c9nonc\u00e9 Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction randint est utilis\u00e9e. Si a et b sont des entiers, randint(a,b) renvoie un nombre entier compris entre a et b . Compl\u00e9ter le code ci-dessous et le tester : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , ... ) nb_test = int ( input ( \"Proposez un nombre entre 1 et 99 : \" )) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test : nb_test = int ( input ( \"Trop petit ! Testez encore : \" )) else : nb_test = int ( input ( \"Trop grand ! Testez encore : \" )) if nb_mystere == nb_test : print ( \"Bravo ! Le nombre \u00e9tait \" , ... ) print ( \"Nombre d'essais: \" , ... ) else : print ( \"Perdu ! Le nombre \u00e9tait \" , ... ) Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , 100 ) nb_test = int ( input ( 'Proposez un nombre entre 1 et 99 : ' )) compteur = 0 while nb_mystere != nb_test and compteur < 10 : compteur = compteur + 1 if nb_mystere > nb_test : nb_test = int ( input ( 'Trop petit ! Testez encore : ' )) else : nb_test = int ( input ( 'Trop grand ! Testez encore : ' )) if nb_mystere == nb_test : print ( 'Bravo ! Le nombre \u00e9tait ' , nb_mystere ) print ( 'Nombre d essais: ' , compteur ) else : print ( 'Perdu ! Le nombre \u00e9tait ' , nb_mystere ) \" ) }}","title":"Exercice 13.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-141","text":"Exercice 14.1 \u00c9nonc\u00e9 \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre et tab un tableau de nombres, et qui renvoie le tableau des indices de elt dans tab si elt est dans tab et le tableau vide [] sinon. Exemples : >>> recherche ( 3 , [ 3 , 2 , 1 , 3 , 2 , 1 ]) [ 0 , 3 ] >>> recherche ( 4 , [ 1 , 2 , 3 ]) [] Correction {{ correction(True, \" 1 2 3 4 5 6 def recherche ( elt , tab ): tab_indices = [] for i in range ( len ( tab )): if tab [ i ] == elt : tab_indices . append ( i ) return tab_indices \" ) }}","title":"Exercice 14.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-142","text":"Exercice 14.2 \u00c9nonc\u00e9 Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : les clefs sont les noms des \u00e9l\u00e8ves ; les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients. Avec : resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ces \u00e9l\u00e8ves et lui renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom ): if nom in ... : notes = resultats [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} def moyenne ( nom ): if nom in resultats : notes = resultats [ nom ] total_points = 0 total_coefficients = 0 for valeurs in notes . values (): note , coefficient = valeurs total_points = total_points + note * coefficient total_coefficients = total_coefficients + coefficient return round ( total_points / total_coefficients , 1 ) else : return - 1 \" ) }}","title":"Exercice 14.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-151","text":"Exercice 15.1 \u00c9nonc\u00e9 \u00c9crire une fonction rechercheMinMax qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s tab , et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> tableau = [ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : - 2 , 'max' : 9 } >>> tableau = [] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : None , 'max' : None } Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 def rechercheMinMax ( tab ): d = {} d [ 'min' ] = None d [ 'max' ] = None for val in tab : if val < d [ 'min' ]: d [ 'min' ] = val if val > d [ 'max' ]: d [ 'max' ] = val return d \" ) }}","title":"Exercice 15.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-152","text":"Exercice 15.2 \u00c9nonc\u00e9 On dispose d\u2019un programme permettant de cr\u00e9er un objet de type PaquetDeCarte , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par #A compl\u00e9ter , puis ajouter des assertions dans l\u2019initialiseur de Carte , ainsi que dans la m\u00e9thode getCarteAt() . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): #A compl\u00e9ter \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): #A compl\u00e9ter Exemple : >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) Correction Attention, le code propos\u00e9 ne respecte pas les standards de notation : il ne faut pas de majuscules sur les noms des attributs la docstring se place \u00e0 l'int\u00e9rieur de la fonction et non au dessus. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): assert c in range ( 1 , 5 ) assert v in range ( 1 , 14 ) self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): for nb_coul in range ( 1 , 5 ): for val in range ( 1 , 14 ): self . contenu . append ( Carte ( nb_coul , val )) \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): assert pos in range ( 56 ) return self . contenu [ pos ]","title":"Exercice 15.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-161","text":"Exercice 16.1 \u00c9nonc\u00e9 \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 Correction {{ correction(True, \" 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) \" ) }}","title":"Exercice 16.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-162","text":"Exercice 16.2 \u00c9nonc\u00e9 On consid\u00e8re la fonction dec_to_bin ci-dessous qui prend en param\u00e8tre un entier positif a en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = ... a = a // 2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter la fonction dec_to_bin . Exemples : >>> dec_to_bin ( 83 ) '1010011' >>> dec_to_bin ( 127 ) '1111111' Correction {{ correction(True, \" 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = '' a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a \" ) }}","title":"Exercice 16.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-171","text":"Exercice 17.1 \u00c9nonc\u00e9 \u00c9crire une fonction indice_du_min qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> indice_du_min ([ 5 ]) 0 >>> indice_du_min ([ 2 , 4 , 1 ]) 2 >>> indice_du_min ([ 5 , 3 , 2 , 2 , 4 ]) 2 Correction {{ correction(True, \" 1 2 3 4 5 6 def indice_du_min ( tab ): indice_min = 0 for i in range ( len ( tab )): if tab [ i ] < tab [ indice_min ]: indice_min = i return indice_min \" ) }}","title":"Exercice 17.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-172","text":"Exercice 17.2 \u00c9nonc\u00e9 On consid\u00e8re la fonction separe ci-dessous qui prend en argument un tableau tab dont les \u00e9l\u00e9ments sont des 0 et des 1 et qui s\u00e9pare les 0 des 1 en pla\u00e7ant les 0 en d\u00e9but de tableau et les 1 \u00e0 la suite. 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = ... while i < j : if tab [ i ] == 0 : i = ... else : tab [ i ], tab [ j ] = ... j = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = len ( tab ) - 1 while i < j : if tab [ i ] == 0 : i = i + 1 else : tab [ i ], tab [ j ] = tab [ j ], tab [ i ] j = j - 1 return tab \" ) }}","title":"Exercice 17.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-181","text":"Exercice 18.1 \u00c9nonc\u00e9 \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 Correction {{ correction(True, \" 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab )): if tab [ i ] == elt : return i return - 1 \" ) }}","title":"Exercice 18.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-182","text":"Exercice 18.2 \u00c9nonc\u00e9 On consid\u00e8re la fonction insere ci-dessous qui prend en argument un entier a et un tableau tab d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur a dans le tableau et renvoie le nouveau tableau. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes python. Sujet l\u00e9g\u00e8rement modifi\u00e9 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = ... while a < ... and i >= ... : l [ i + 1 ] = ... l [ i ] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : >>> insere ( 3 ,[ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 10 ,[ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 10 , 12 , 14 , 25 ] >>> insere ( 1 ,[ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = len ( l ) - 2 while a < l [ i ] and i >= 0 : l [ i + 1 ] = l [ i ] l [ i ] = a i = i - 1 return l \" ) }}","title":"Exercice 18.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-191","text":"Exercice 19.1 \u00c9nonc\u00e9 \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, -1 sinon. Exemples : >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1 \" ) }}","title":"Exercice 19.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-192","text":"Exercice 19.2 \u00c9nonc\u00e9 Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve et -1 sinon. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for ... in message : if lettre in ALPHABET : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for lettre in message : if lettre in ALPHABET : indice = ( position_alphabet ( lettre ) + decalage ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = resultat + lettre return resultat \" ) }}","title":"Exercice 19.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-201","text":"Exercice 20.1 \u00c9nonc\u00e9 On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] \u00c9crire la fonction mini qui prend en param\u00e8tres le tableau releve des relev\u00e9s et le tableau date des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. Exemple : >>> mini ( t_moy , annees ) ( 12.5 , 2016 ) Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] def mini ( releve , date ): temp_mini = releve [ 0 ] date_mini = date [ 0 ] for i in range ( len ( releve )): if releve [ i ] < temp_mini : temp_mini = releve [ i ] date_mini = date [ i ] return temp_mini , date_mini \" ) }}","title":"Exercice 20.1 \ud83d\uddf9"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-202","text":"Exercice 20.2 \u00c9nonc\u00e9 Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : bob , radar , et non sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction est_nbre_palindrome s\u2019appuiera sur la fonction est_palindrome qui elle-m\u00eame s\u2019appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res chaine et renvoie la cha\u00eene invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbre_palindrome teste si un nombre nbre est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. def inverse_chaine ( chaine ): result = ... for caractere in chaine : result = ... return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return ... def est_nbre_palindrome ( nbre ): chaine = ... return est_palindrome ( chaine ) Exemples : >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 def inverse_chaine ( chaine ): result = '' for caractere in chaine : result = caractere + result return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return chaine == inverse def est_nbre_palindrome ( nbre ): chaine = str ( nbre ) return est_palindrome ( chaine ) \" ) }}","title":"Exercice 20.2 \ud83d\uddf9"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-211","text":"Exercice 21.1 \u00c9nonc\u00e9 \u00c9crire une fonction python appel\u00e9e nb_repetitions qui prend en param\u00e8tres un \u00e9l\u00e9ment elt et une liste tab et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : >>> nb_repetitions ( 5 ,[ 2 , 5 , 3 , 5 , 6 , 9 , 5 ]) 3 >>> nb_repetitions ( 'A' ,[ 'B' , 'A' , 'B' , 'A' , 'R' ]) 2 >>> nb_repetitions ( 12 ,[ 1 , '! ' , 7 , 21 , 36 , 44 ]) 0 Correction {{ correction(True, \" 1 2 3 4 5 6 def nb_repetitions ( elt , tab ): nb = 0 for element in tab : if element == elt : nb += 1 return nb \" ) }}","title":"Exercice 21.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-212","text":"Exercice 21.2 \u00c9nonc\u00e9 Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( ... ) a = a // 2 while a ... : bin_a = ... ( a % 2 ) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' Correction {{ correction(True, \" 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a \" ) }}","title":"Exercice 21.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-221","text":"Exercice 22.1 \u00c9nonc\u00e9 \u00c9crire en langage Python une fonction recherche prenant comme param\u00e8tres une variable a de type num\u00e9rique ( float ou int ) et un tableau t (type list ) et qui renvoie le nombre d'occurrences de a dans t . Exemples : >>> recherche ( 5 ,[]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 4 , 8 ]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 1 , 5 , 3 , 7 , 4 ]) 1 >>> recherche ( 5 ,[ - 2 , 5 , 3 , 5 , 4 , 5 ]) 3 Correction {{ correction(True, \" 1 2 3 4 5 6 def recherche ( a , t ): nb = 0 for element in t : if element == a : nb += 1 return nb \" ) }}","title":"Exercice 22.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-222","text":"Exercice 22.2 \u00c9nonc\u00e9 La fonction rendu_monnaie_centimes prend en param\u00e8tres deux nombres entiers positifs s_due et s_versee et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence s_versee \u2013 s_due pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. La fonction renvoie la liste des pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en centimes d\u2019euros. Les valeurs possibles pour les pi\u00e8ces sont donc [1, 2, 5, 10, 20, 50, 100, 200] . Ainsi, l\u2019instruction rendu_monnaie_centimes(452, 500) renverra [20, 20, 5, 2, 1] . En effet, la somme \u00e0 rendre est de 48 centimes soit 20 + 20 + 5 + 2 + 1 . Le code de la fonction est donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = ... a_rendre = ... i = len ( pieces ) - 1 while a_rendre > ... : if pieces [ i ] <= a_rendre : rendu . append ( ... ) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code pour qu'il donne : >>> rendu_monnaie_centimes ( 700 , 700 ) [] >>> rendu_monnaie_centimes ( 112 , 500 ) [ 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = [] a_rendre = s_versee - s_due i = len ( pieces ) - 1 while a_rendre > 0 : if pieces [ i ] <= a_rendre : rendu . append ( pieces [ i ]) a_rendre = a_rendre - pieces [ i ] else : i = i - 1 return rendu \" ) }}","title":"Exercice 22.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-231","text":"Exercice 23.1 \u00c9nonc\u00e9 L\u2019occurrence d\u2019un caract\u00e8re dans un phrase est le nombre de fois o\u00f9 ce caract\u00e8re est pr\u00e9sent. Exemples : l\u2019occurrence du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; l\u2019occurrence du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : {'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1} \u00c9crire une fonction occurence_lettres prenant comme param\u00e8tre une variable phrase de type str . Cette fonction doit renvoyer un dictionnaire de type constitu\u00e9 des occurrences des caract\u00e8res pr\u00e9sents dans la phrase. Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 def occurence_lettres ( phrase ): occ = {} for caractere in phrase : if caractere in occ : occ [ caractere ] += 1 else : occ [ caractere ] = 1 return occ \" ) }}","title":"Exercice 23.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-232","text":"Exercice 23.2 \u00c9nonc\u00e9 La fonction fusion prend deux listes L1 , L2 d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e L12 qu\u2019elle renvoie. Le code Python de la fonction est 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = ... i1 = ... else : L12 [ i ] = L2 [ i2 ] i2 = ... i += 1 while i1 < n1 : L12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : L12 [ i ] = ... i2 = i2 + 1 i = ... return L12 Compl\u00e9ter le code. Exemple : >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and i2 < n2 : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 else : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i += 1 while i1 < n1 : L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 i = i + 1 while i2 < n2 : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i = i + 1 return L12 \" ) }}","title":"Exercice 23.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-241","text":"identique au 18.1 Exercice 24.1 \u00c9nonc\u00e9 \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1 \" ) }}","title":"Exercice 24.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-242","text":"Exercice 24.2 \u00c9nonc\u00e9 On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de 192.168.0.0 \u00e0 192.168.0.255 . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP 192.168.0.0 et 192.168.0.255 sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe AdresseIP . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class AdresseIP : def __init__ ( self , adresse ): self . adresse = ... def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254 : octet_nouveau = ... + ... return AdresseIP ( '192.168.0.' + ... ) else : return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class AdresseIP : def __init__ ( self , adresse ): self . adresse = adresse def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return self . liste_octet ()[ 3 ] == 0 or self . liste_octet ()[ 3 ] == 255 def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if self . liste_octet ()[ 3 ] < 254 : octet_nouveau = self . liste_octet ()[ 3 ] + 1 return AdresseIP ( '192.168.0.' + str ( octet_nouveau )) else : return False adresse1 = AdresseIP ( '192.168.0.1' ) adresse2 = AdresseIP ( '192.168.0.2' ) adresse3 = AdresseIP ( '192.168.0.0' )","title":"Exercice 24.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-251","text":"Exercice 25.1 \u00c9nonc\u00e9 \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] Correction {{ correction(True, \" 1 2 3 4 5 6 def recherche ( tab ): solution = [] for i in range ( len ( tab ) - 1 ): if tab [ i ] + 1 == tab [ i + 1 ]: solution . append (( tab [ i ], tab [ i + 1 ])) return solution \" ) }}","title":"Exercice 25.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-252","text":"Exercice 25.2 \u00c9nonc\u00e9 Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M , deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M,2,1,3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == ... ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( ... ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , ... , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( ... ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , ... , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( ... ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , ... , val ) Exemple : >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == 0 : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == 1 ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( i + 1 ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , i + 1 , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( j - 1 ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , j - 1 , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( j + 1 ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , j + 1 , val ) \" ) }}","title":"Exercice 25.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-261","text":"Exercice 26.1 \u00c9nonc\u00e9 \u00c9crire une fonction occurrence_max prenant en param\u00e8tres une cha\u00eene de caract\u00e8res chaine et qui renvoie le caract\u00e8re le plus fr\u00e9quent de la cha\u00eene. La chaine ne contient que des lettres en minuscules sans accent. On pourra s\u2019aider du tableau alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o,','p','q','r','s','t','u','v','w','x','y','z'] et du tableau occurrence de 26 \u00e9l\u00e9ments o\u00f9 l\u2019on mettra dans occurrence[i] le nombre d\u2019apparitions de alphabet[i] dans la chaine. Puis on calculera l\u2019indice k d\u2019un maximum du tableau occurrence et on affichera alphabet[k] . Exemple : >>> ch = 'je suis en terminale et je passe le bac et je souhaite poursuivre des etudes pour devenir expert en informatique' >>> occurrence_max ( ch ) \u2018 e \u2019 Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 alphabet = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o,' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' ] def occurrence_max ( chaine ): occurence = [ 0 ] * 26 for i in range ( 26 ): compteur = 0 for caractere in chaine : if caractere == alphabet [ i ]: compteur += 1 occurence [ i ] = compteur ind_max = 0 for i in range ( 26 ): if occurence [ i ] > occurence [ ind_max ]: ind_max = i return alphabet [ ind_max ] \" ) }}","title":"Exercice 26.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-262","text":"Exercice 26.2 \u00c9nonc\u00e9 On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Compl\u00e9ter le programme ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return ... def nbCol ( image ): '''renvoie la largeur de l'image''' return ... def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): L [ i ][ j ] = ... return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): if image [ i ][ j ] < ... : L [ i ][ j ] = ... else : L [ i ][ j ] = ... return L Exemple : >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 287 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , - 32 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( negatif ( img ), 120 ) [[ 1 , 1 , 0 , 0 , 1 ], [ 1 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 ], [ 0 , 1 , 1 , 0 , 0 ]] Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return len ( image ) def nbCol ( image ): '''renvoie la largeur de l'image''' return len ( image [ 0 ]) def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): L [ i ][ j ] = 255 - image [ i ][ j ] return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): if image [ i ][ j ] < seuil : L [ i ][ j ] = 0 else : L [ i ][ j ] = 1 return L","title":"Exercice 26.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-271","text":"Exercice 27.1 \u00c9nonc\u00e9 \u00c9crire une fonction moyenne prenant en param\u00e8tres une liste d\u2019entiers et qui renvoie la moyenne des valeurs de cette liste. Exemple : >>> moyenne ([ 10 , 20 , 30 , 40 , 60 , 110 ]) 45.0 Correction {{ correction(True, \" 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) \" ) }}","title":"Exercice 27.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-272","text":"Exercice 27.2 \u00c9nonc\u00e9 On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction affiche permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction zoomListe prend en argument une liste liste_depart et un entier k . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de liste_depart est dupliqu\u00e9 k fois. La fonction zoomDessin prend en argument la grille dessin et renvoie une grille o\u00f9 toutes les lignes de dessin sont zoom\u00e9es k fois et r\u00e9p\u00e9t\u00e9es k fois. Soit le code ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin : for col in ligne : if col == 1 : print ( \" *\" , end = \"\" ) else : print ( \" \" , end = \"\" ) print () def zoomListe ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range ( k ): ... return liste_zoom def zoomDessin ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom = [] for elt in grille : liste_zoom = ... for i in range ( k ): ... . append ( ... ) return grille_zoom R\u00e9sultats \u00e0 obtenir : >>> affiche ( coeur ) >>> affiche ( zoomDessin ( coeur , 3 )) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): for ligne in dessin : for col in ligne : if col == 1 : print ( ' *' , end = '' ) else : print ( ' ' , end = '' ) print () def zoomListe ( liste_depart , k ): liste_zoom = [] for elt in liste_depart : for i in range ( k ): liste_zoom . append ( elt ) return liste_zoom def zoomDessin ( grille , k ): grille_zoom = [] for elt in grille : liste_zoom = zoomListe ( elt , k ) for i in range ( k ): grille_zoom . append ( liste_zoom ) return grille_zoom","title":"Exercice 27.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-281","text":"Exercice 28.1 \u00c9nonc\u00e9 Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre est stock\u00e9 dans a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], \\ 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], \\ 'H' :[ '' , '' ]} \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tres un arbre binaire arbre sous la forme d\u2019un dictionnaire et un caract\u00e8re lettre qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153ud. On pourra distinguer les 4 cas o\u00f9 les deux \u00ab fils \u00bb du n\u0153ud sont '' , le fils gauche seulement est '' , le fils droit seulement est '' , aucun des deux fils n\u2019est '' . Exemple : >>> taille ( a , \u2019 F \u2019 ) 9 Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], 'H' :[ '' , '' ]} def taille ( arbre , lettre ): fils_gauche = arbre [ lettre ][ 0 ] fils_droit = arbre [ lettre ][ 1 ] if fils_gauche != '' and fils_droit != '' : return 1 + taille ( arbre , fils_gauche ) + taille ( arbre , fils_droit ) if fils_gauche != '' and fils_droit == '' : return 1 + taille ( arbre , fils_gauche ) if fils_gauche == '' and fils_droit != '' : return 1 + taille ( arbre , fils_droit ) else : return 1 \" ) }}","title":"Exercice 28.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-282","text":"Exercice 28.2 \u00c9nonc\u00e9 On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt depuis le d\u00e9but du tableau tous les \u00e9l\u00e9ments non rang\u00e9s et on place en derni\u00e8re position le plus grand \u00e9l\u00e9ment. Exemple avec le tableau : t = [41, 55, 21, 18, 12, 6, 25] \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus grand \u00e9l\u00e9ment avec le dernier. Le tableau devient t = [41, 25, 21, 18, 12, 6, 55] \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le dernier , on permute le plus grand \u00e9l\u00e9ment trouv\u00e9 avec l'avant dernier. Le tableau devient : t = [6, 25, 21, 18, 12, 41, 55] Et ainsi de suite. La code de la fonction tri_iteratif qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( ... , 0 , - 1 ): imax = ... for i in range ( 0 , ... ): if tab [ i ] > ... : imax = i if tab [ max ] > ... : ... , tab [ imax ] = tab [ imax ], ... return tab Compl\u00e9ter le code qui doit donner : >>> tri_iteratif ([ 41 , 55 , 21 , 18 , 12 , 6 , 25 ]) [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et b . Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( len ( tab ) - 1 , 0 , - 1 ): imax = 0 for i in range ( 0 , k ): if tab [ i ] > tab [ imax ] : imax = i if tab [ imax ] > tab [ k ] : tab [ k ], tab [ imax ] = tab [ imax ], tab [ k ] return tab \" ) }}","title":"Exercice 28.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-291","text":"Exercice 29.1 \u00c9nonc\u00e9 Soit un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 1 : s'il est pair, on le divise par 2 ; s\u2019il est impair, on le multiplie par 3 et on ajoute 1. Puis on recommence ces \u00e9tapes avec le nombre entier obtenu, jusqu\u2019\u00e0 ce que l\u2019on obtienne la valeur 1. On d\u00e9finit ainsi la suite \\((U_n)\\) par : \\(U_0=k\\) , o\u00f9 \\(k\\) est un entier choisi initialement; \\(U_{n+1} = \\dfrac{U_n}{2}\\) si \\(U_n\\) est pair; \\(U_{n+1} = 3 \\times U_n + 1\\) si \\(U_n\\) est impair. On admet que, quel que soit l'entier k choisi au d\u00e9part, la suite finit toujours sur la valeur 1. \u00c9crire une fonction calcul prenant en param\u00e8tres un entier n strictement positif et qui renvoie la liste des valeurs de la suite, en partant de n et jusqu'\u00e0 atteindre 1. Exemple : >>> calcul ( 7 ) [ 7 , 22 , 11 , 34 , 17 , 52 , 26 , 13 , 40 , 20 , 10 , 5 , 16 , 8 , 4 , 2 , 1 ] Correction {{ correction(True, \" \" ) }}","title":"Exercice 29.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-292","text":"Exercice 29.2 \u00c9nonc\u00e9 On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction est_parfait ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res mot (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de mot , ainsi qu\u2019un bool\u00e9en qui indique si mot est parfait ou pas. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = ??? for c in mot : code_c = code_c + ??? code_a = ??? code_c = int ( code_c ) if ??? : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] Exemples : >>> est_parfait ( \"PAUL\" ) [ 50 , 1612112 , False ] >>> est_parfait ( \"ALAIN\" ) [ 37 , 1121914 , True ] Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = 0 for c in mot : code_c = code_c + str ( dico [ c ]) code_a = code_a + dico [ c ] code_c = int ( code_c ) if code_c % code_a == 0 : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ]","title":"Exercice 29.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-301","text":"Exercice 30.1 \u00c9nonc\u00e9 Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat \" ) }}","title":"Exercice 30.1 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/EP_NSI_corriges/#exercice-302","text":"Exercice 30.2 \u00c9nonc\u00e9 Soit T un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et n un entier. La fonction chercher , donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur n appara\u00eet \u00e9ventuellement dans T , et None sinon. Les param\u00e8tres de la fonction sont : T , le tableau dans lequel s'effectue la recherche ; n , l'entier \u00e0 chercher dans le tableau ; i , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; j , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction chercher est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si 0 <= i et j < len(T) . Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche \"Erreur\" puis renvoie None . Recopier et compl\u00e9ter le code de la fonction chercher propos\u00e9e ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or ??? : print ( \"Erreur\" ) return None if i > j : return None m = ( i + j ) // ??? if T [ m ] < ??? : return chercher ( T , n , ??? , ??? ) elif ??? : return chercher ( T , n , ??? , ??? ) else : return ??? L'ex\u00e9cution du code doit donner : >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) Erreur >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 Correction {{ correction(True, \" 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or j >= len ( T ) : print ( 'Erreur' ) return None if i > j : return None m = ( i + j ) // 2 if T [ m ] < n : return chercher ( T , n , m + 1 , j ) elif T [ m ] > n : return chercher ( T , n , i , m - 1 ) else : return m \" ) }} Sources en Markdown Soit `T` un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et `n` un entier. La fonction `chercher`, donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur `n` appara\u00eet \u00e9ventuellement dans `T`, et `None` sinon. Les param\u00e8tres de la fonction sont : - `T`, le tableau dans lequel s'effectue la recherche ; - `n`, l'entier \u00e0 chercher dans le tableau ; - `i`, l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; - `j`, l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction `chercher` est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si `0 <= i` et `j < len(T)`. Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche `\"Erreur\"` puis renvoie `None`. Recopier et compl\u00e9ter le code de la fonction `chercher` propos\u00e9e ci-dessous : ```python linenums='1' def chercher(T, n, i, j): if i < 0 or ??? : print(\"Erreur\") return None if i > j : return None m = (i + j) // ??? if T[m] < ??? : return chercher(T, n, ??? , ???) elif ??? : return chercher(T, n, ??? , ??? ) else : return ??? ``` L'ex\u00e9cution du code doit donner : ```python >>> chercher([1,5,6,6,9,12],7,0,10) Erreur >>> chercher([1,5,6,6,9,12],7,0,5) >>> chercher([1,5,6,6,9,12],9,0,5) 4 >>> chercher([1,5,6,6,9,12],6,0,5) 2 ```","title":"Exercice 30.2 \u25a1"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/reglement/","text":"Nature de l'\u00e9preuve Textes r\u00e8glementaires https://www.education.gouv.fr/bo/20/Special2/MENE2001797N.htm?cid_bo=149244 L'\u00e9preuve terminale obligatoire de sp\u00e9cialit\u00e9 est compos\u00e9e de deux parties : une partie \u00e9crite , comptant pour 12 points sur 20, et une partie pratique comptant pour 8 points sur 20. La note globale de l'\u00e9preuve est donn\u00e9e sur 20 points. Epreuve \u00e9crite Modalit\u00e9s Dur\u00e9e : 3 heures 30 La partie \u00e9crite consiste en la r\u00e9solution de trois exercices permettant d'\u00e9valuer les connaissances et les capacit\u00e9s attendues conform\u00e9ment aux programmes de premi\u00e8re et de terminale de la sp\u00e9cialit\u00e9. Chaque exercice est not\u00e9 sur 4 points . Le sujet propose cinq exercices , parmi lesquels le candidat choisit les trois qu'il traitera. Ces cinq exercices permettent d'aborder les diff\u00e9rentes rubriques du programme, sans obligation d'exhaustivit\u00e9. Le sujet comprend obligatoirement au moins un exercice relatif \u00e0 chacune des trois rubriques suivantes : traitement de donn\u00e9es en tables et bases de donn\u00e9es ; architectures mat\u00e9rielles, syst\u00e8mes d'exploitation et r\u00e9seaux ; algorithmique, langages et programmation. \u00c9preuve pratique Modalit\u00e9s Dur\u00e9e : 1 heure L'\u00e9preuve pratique donne lieu \u00e0 une note sur 8 points , qui s'ajouteront aux 12 points de l'\u00e9preuve \u00e9crite. La partie pratique consiste en la r\u00e9solution de deux exercices sur ordinateur , chacun \u00e9tant not\u00e9 sur 4 points . Le candidat est \u00e9valu\u00e9 sur la base d\u2019un dialogue avec un professeur-examinateur. Un examinateur \u00e9value au maximum quatre \u00e9l\u00e8ves. L\u2019examinateur ne peut pas \u00e9valuer un \u00e9l\u00e8ve qu\u2019il a eu en classe durant l\u2019ann\u00e9e en cours. L\u2019\u00e9valuation de cette partie se d\u00e9roule au cours du deuxi\u00e8me trimestre pendant la p\u00e9riode de l\u2019\u00e9preuve \u00e9crite de sp\u00e9cialit\u00e9. Premier exercice Le premier exercice consiste \u00e0 programmer un algorithme figurant explicitement au programme, ne pr\u00e9sentant pas de difficult\u00e9 particuli\u00e8re, dont on fournit une sp\u00e9cification. Il s\u2019agit donc de restituer un algorithme rencontr\u00e9 et travaill\u00e9 \u00e0 plusieurs reprises en cours de formation. Le sujet peut proposer un jeu de test avec les r\u00e9ponses attendues pour permettre au candidat de v\u00e9rifier son travail. Deuxi\u00e8me exercice Pour le second exercice, un programme est fourni au candidat. Cet exercice ne demande pas l\u2019\u00e9criture compl\u00e8te d\u2019un programme, mais permet de valider des comp\u00e9tences de programmation suivant des modalit\u00e9s vari\u00e9es : le candidat doit, par exemple, compl\u00e9ter un programme \u00ab \u00e0 trous \u00bb afin de r\u00e9pondre \u00e0 une sp\u00e9cification donn\u00e9e, ou encore compl\u00e9ter un programme pour le documenter, ou encore compl\u00e9ter un programme en ajoutant des assertions, etc. Banque d'exercices Textes r\u00e8glementaires https://eduscol.education.fr/2661/banque-des-epreuves-pratiques-de-specialite-nsi La banque d'exercices est publique et peut \u00eatre t\u00e9l\u00e9charg\u00e9e en un pdf unique ici .","title":"R\u00e8glement des \u00e9preuves de terminale"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/reglement/#nature-de-lepreuve","text":"Textes r\u00e8glementaires https://www.education.gouv.fr/bo/20/Special2/MENE2001797N.htm?cid_bo=149244 L'\u00e9preuve terminale obligatoire de sp\u00e9cialit\u00e9 est compos\u00e9e de deux parties : une partie \u00e9crite , comptant pour 12 points sur 20, et une partie pratique comptant pour 8 points sur 20. La note globale de l'\u00e9preuve est donn\u00e9e sur 20 points.","title":"Nature de l'\u00e9preuve"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/reglement/#epreuve-ecrite","text":"","title":"Epreuve \u00e9crite"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/reglement/#modalites","text":"Dur\u00e9e : 3 heures 30 La partie \u00e9crite consiste en la r\u00e9solution de trois exercices permettant d'\u00e9valuer les connaissances et les capacit\u00e9s attendues conform\u00e9ment aux programmes de premi\u00e8re et de terminale de la sp\u00e9cialit\u00e9. Chaque exercice est not\u00e9 sur 4 points . Le sujet propose cinq exercices , parmi lesquels le candidat choisit les trois qu'il traitera. Ces cinq exercices permettent d'aborder les diff\u00e9rentes rubriques du programme, sans obligation d'exhaustivit\u00e9. Le sujet comprend obligatoirement au moins un exercice relatif \u00e0 chacune des trois rubriques suivantes : traitement de donn\u00e9es en tables et bases de donn\u00e9es ; architectures mat\u00e9rielles, syst\u00e8mes d'exploitation et r\u00e9seaux ; algorithmique, langages et programmation.","title":"Modalit\u00e9s"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/reglement/#epreuve-pratique","text":"","title":"\u00c9preuve pratique"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/reglement/#modalites_1","text":"Dur\u00e9e : 1 heure L'\u00e9preuve pratique donne lieu \u00e0 une note sur 8 points , qui s'ajouteront aux 12 points de l'\u00e9preuve \u00e9crite. La partie pratique consiste en la r\u00e9solution de deux exercices sur ordinateur , chacun \u00e9tant not\u00e9 sur 4 points . Le candidat est \u00e9valu\u00e9 sur la base d\u2019un dialogue avec un professeur-examinateur. Un examinateur \u00e9value au maximum quatre \u00e9l\u00e8ves. L\u2019examinateur ne peut pas \u00e9valuer un \u00e9l\u00e8ve qu\u2019il a eu en classe durant l\u2019ann\u00e9e en cours. L\u2019\u00e9valuation de cette partie se d\u00e9roule au cours du deuxi\u00e8me trimestre pendant la p\u00e9riode de l\u2019\u00e9preuve \u00e9crite de sp\u00e9cialit\u00e9. Premier exercice Le premier exercice consiste \u00e0 programmer un algorithme figurant explicitement au programme, ne pr\u00e9sentant pas de difficult\u00e9 particuli\u00e8re, dont on fournit une sp\u00e9cification. Il s\u2019agit donc de restituer un algorithme rencontr\u00e9 et travaill\u00e9 \u00e0 plusieurs reprises en cours de formation. Le sujet peut proposer un jeu de test avec les r\u00e9ponses attendues pour permettre au candidat de v\u00e9rifier son travail. Deuxi\u00e8me exercice Pour le second exercice, un programme est fourni au candidat. Cet exercice ne demande pas l\u2019\u00e9criture compl\u00e8te d\u2019un programme, mais permet de valider des comp\u00e9tences de programmation suivant des modalit\u00e9s vari\u00e9es : le candidat doit, par exemple, compl\u00e9ter un programme \u00ab \u00e0 trous \u00bb afin de r\u00e9pondre \u00e0 une sp\u00e9cification donn\u00e9e, ou encore compl\u00e9ter un programme pour le documenter, ou encore compl\u00e9ter un programme en ajoutant des assertions, etc.","title":"Modalit\u00e9s"},{"location":"10_Annales%20des%20%C3%A9preuves%20pratiques/reglement/#banque-dexercices","text":"Textes r\u00e8glementaires https://eduscol.education.fr/2661/banque-des-epreuves-pratiques-de-specialite-nsi La banque d'exercices est publique et peut \u00eatre t\u00e9l\u00e9charg\u00e9e en un pdf unique ici .","title":"Banque d'exercices"},{"location":"1_Langage%20et%20programmation/Base_python/","text":"Structures de base d\u2019un programme Format PDF Un programme est un texte qui d\u00e9crit un algorithme que l\u2019on souhaite faire ex\u00e9cuter par une machine. Ce texte est \u00e9crit dans un langage particulier, appel\u00e9 langage de programmation. Il existe plusieurs milliers de langages de programmation, parmi lesquels Python, Java, C, Caml, Fortran, Cobol, etc. Il n\u2019est cependant pas n\u00e9cessaire d\u2019apprendre ces langages les uns apr\u00e8s les autres, car ils sont tous plus ou moins organis\u00e9s autour des m\u00eames notions : affectation , s\u00e9quence , test , boucle , fonction , etc. Le langage principal qui sera utilis\u00e9 durant ces deux ann\u00e9es de sp\u00e9cialit\u00e9 NSI est le langage Python. Apprendre la programmation, ce n\u2019est pas seulement apprendre \u00e0 \u00e9crire un programme, c\u2019est aussi comprendre de quoi il est fait, comment il est fait et ce qu\u2019il fait. Un programme est essentiellement constitu\u00e9 d\u2019 expressions et d\u2019 instructions . Nous introduisons dans ce cours trois instructions fondamentales que sont l \u2019affectation de variables, le test et la boucle . L\u2019affectation de variables L\u2019essentiel du travail effectu\u00e9 par un programme d\u2019ordinateur consiste \u00e0 manipuler des donn\u00e9es organis\u00e9es comme un ensemble de variable. Une variable appara\u00eet dans un langage de programmation sous un nom de variable qui doit \u00eatre explicite. Pour l\u2019ordinateur ce nom est une r\u00e9f\u00e9rence d\u00e9signant une adresse m\u00e9moire, c\u2019est-\u00e0-dire un emplacement pr\u00e9cis dans la m\u00e9moire vive. Pour stocker une valuer dans une variable, on utilise une instruction appel\u00e9e affectation, not\u00e9e par le signe = . Par exemple, l'affectation x = y + 3 est compos\u00e9e d\u2019une variable x et d\u2019une expression y + 3 . Les op\u00e9rations Op\u00e9ration sur des r\u00e9els Op\u00e9rations bool\u00e9ennes + Addition - Soustraction * Multiplication / Division // Quotient de la division euclidienne % Reste de la division euclidienne ** Puissance Le r\u00e9sultat d\u2019une expression bool\u00e9enne en peut prendre que deux \u00e9tats, vrai ( True en python) ou faux ( False ) Affectations multiples On peut assigner une valeur \u00e0 plusieurs variables simultan\u00e9ment. Exemple : >>> x = y = 7 On peut aussi effectuer des affectations parall\u00e8les \u00e0 l\u2019aide d\u2019un seul op\u00e9rateur : >>> a, b = 4, 8.33 Les bonne pratique de nommage Un nom de variable est une s\u00e9quence de lettres (a \u2192 z , A \u2192 Z) et de chiffres (0 \u2192 9), qui doit toujours commencer par une lettre. Seules les lettres ordinaires sont autoris\u00e9es. Les lettres accentu\u00e9es, les c\u00e9dilles, les espaces, les caract\u00e8res sp\u00e9ciaux tels que $, #, @, etc. sont interdits, \u00e0 l\u2019exception du caract\u00e8re _ (soulign\u00e9). La casse est significative (les caract\u00e8res majuscules et minuscules sont distingu\u00e9s). Le nommage des variables doit \u00eatre le plus explicite possible afin de simplifier la compr\u00e9hension du programme Le nom d\u2019une variable commence toujours par une minuscule Vous ne pouvez pas utiliser comme nom de variables les 33 \u00ab mots r\u00e9serv\u00e9s \u00bb ci-dessous ( utilis\u00e9s par le langage lui-m\u00eame) : and as assert break class continue def del elif else except False finally for from global if import in is lambda None nonlocal not or pass raise return True try while with yield Le test Si nous voulons pouvoir \u00e9crire des applications v\u00e9ritablement utiles, il nous faut des technique permettant d\u2019aiguiller le d\u00e9roulement du programme dans diff\u00e9rentes directions, en fonction des circonstances rencontr\u00e9es. En Python, la syntaxe d\u2019une instruction conditionnelle est la suivante : if expression : Instruction1 Instruction2 Instruction3 else : Instruction4 Instruction5 Remarquez les points suivants : la ligne de test commence par if , et la condition est suivie d\u2019un deux points (indispensable, sinon Python arr\u00eatera le script avec une erreur de syntaxe). les instructions 1 , 2 et 3 sont celles qui seront ex\u00e9cut\u00e9es si la condition est vraie ( True ) Ces instructions doivent \u00eatre indent\u00e9es (d\u00e9cal\u00e9es vers la droite) du m\u00eame nombre de tabulation pour indiquer qu\u2019elles font partie du m\u00eame if . La partie else instruction4 instruction5 est facultative. Ces instructions seront ex\u00e9cut\u00e9es seulement si la condition qui suit le if est fausse ( False ) Le mot else doit \u00eatre suivi d\u2019un deux-points ; il doit \u00eatre align\u00e9 avec le if auquel il correspond. Lorsqu\u2019on veut encha\u00eener plusieurs tests, on peut utiliser l\u2019instruction elif , qui est la contraction de else if . Cette instruction doit \u00eatre align\u00e9e avec le if correspondant, et elle doit \u00eatre suivie d\u2019une condition, puis d\u2019un deux-points et apr\u00e8s d\u2019instructions indent\u00e9es, comme pour un if . Les instructions seront ex\u00e9cut\u00e9es si la condition qui suit le if est fausse, mais que la condition qui suit le elif est vraie. La boucle En programmation, on appelle boucle un syst\u00e8me d\u2019instructions qui permet de r\u00e9p\u00e9ter un certain nombre de fois (voire ind\u00e9finiment) toute une s\u00e9rie d\u2019op\u00e9rations. Python propose deux instructions particuli\u00e8res pour construire des boucles : l\u2019instruction for et l\u2019instruction while La boucle non born\u00e9e While Le mot while signifie \u00ab tant que \u00bb en anglais. Cette instruction r\u00e9p\u00e9te continuellement le bloc d\u2019instructions qui suit, tant que l\u2019expression est vraie. while expression : Instruction1 Instruction2 Instruction3 Instruction4 Instruction5 la boucle born\u00e9e for La syntaxe d\u2019une boucle for est la suivante : for i in range ( e , e \u2019 ) : Instruction1 Instruction2 Instruction3 Instruction4 i est une variable, e et e\u2019 sont des expressions et instruction1 , instructions2 sont des instructions, appel\u00e9e corps de cette boucle. C\u2019est lui qui va s\u2019ex\u00e9cuter autant de fois que pr\u00e9cis\u00e9 dans la boucle. Comme dans le cas des tests, le corps d\u2019une boucle doit \u00eatre indent\u00e9. Cette boucle a pour effet d\u2019ex\u00e9cuter le corps de boucle ( n - m ) fois, o\u00f9 m est la valeur de l\u2019expression e et n celle de l\u2019expression e\u2019 . Pour chaque tour de boucle la valeur de la variable i est successivement m , m+1 , ..., n\u22121 . Par exemple, ex\u00e9cuter la boucle : for i in range ( 1 , 11 ): print ( \"all\u00f4 \" , end = \"\" ) print ( \"t\u2019es o\u00f9 ?\" ) * a pour effet d\u2019afficher : all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 t'es o\u00f9 ? Choisir entre une boucle for et la boucle while Si on conna\u00eet \u00e0 l\u2019avance le nombre de r\u00e9p\u00e9titions \u00e0 effectuer, la boucle for est toute indiqu\u00e9e. \u00c0 l\u2019inverse, si la d\u00e9cision d\u2019arr\u00eater la boucle ne peut s\u2019exprimer que par un test, c\u2019est la boucle while qu\u2019il faut choisir.","title":"Les bases du langage Python"},{"location":"1_Langage%20et%20programmation/Base_python/#structures-de-base-dun-programme","text":"Format PDF Un programme est un texte qui d\u00e9crit un algorithme que l\u2019on souhaite faire ex\u00e9cuter par une machine. Ce texte est \u00e9crit dans un langage particulier, appel\u00e9 langage de programmation. Il existe plusieurs milliers de langages de programmation, parmi lesquels Python, Java, C, Caml, Fortran, Cobol, etc. Il n\u2019est cependant pas n\u00e9cessaire d\u2019apprendre ces langages les uns apr\u00e8s les autres, car ils sont tous plus ou moins organis\u00e9s autour des m\u00eames notions : affectation , s\u00e9quence , test , boucle , fonction , etc. Le langage principal qui sera utilis\u00e9 durant ces deux ann\u00e9es de sp\u00e9cialit\u00e9 NSI est le langage Python. Apprendre la programmation, ce n\u2019est pas seulement apprendre \u00e0 \u00e9crire un programme, c\u2019est aussi comprendre de quoi il est fait, comment il est fait et ce qu\u2019il fait. Un programme est essentiellement constitu\u00e9 d\u2019 expressions et d\u2019 instructions . Nous introduisons dans ce cours trois instructions fondamentales que sont l \u2019affectation de variables, le test et la boucle .","title":"Structures de base d\u2019un programme"},{"location":"1_Langage%20et%20programmation/Base_python/#laffectation-de-variables","text":"L\u2019essentiel du travail effectu\u00e9 par un programme d\u2019ordinateur consiste \u00e0 manipuler des donn\u00e9es organis\u00e9es comme un ensemble de variable. Une variable appara\u00eet dans un langage de programmation sous un nom de variable qui doit \u00eatre explicite. Pour l\u2019ordinateur ce nom est une r\u00e9f\u00e9rence d\u00e9signant une adresse m\u00e9moire, c\u2019est-\u00e0-dire un emplacement pr\u00e9cis dans la m\u00e9moire vive. Pour stocker une valuer dans une variable, on utilise une instruction appel\u00e9e affectation, not\u00e9e par le signe = . Par exemple, l'affectation x = y + 3 est compos\u00e9e d\u2019une variable x et d\u2019une expression y + 3 .","title":"L\u2019affectation de variables"},{"location":"1_Langage%20et%20programmation/Base_python/#les-operations","text":"Op\u00e9ration sur des r\u00e9els Op\u00e9rations bool\u00e9ennes + Addition - Soustraction * Multiplication / Division // Quotient de la division euclidienne % Reste de la division euclidienne ** Puissance Le r\u00e9sultat d\u2019une expression bool\u00e9enne en peut prendre que deux \u00e9tats, vrai ( True en python) ou faux ( False )","title":"Les op\u00e9rations"},{"location":"1_Langage%20et%20programmation/Base_python/#affectations-multiples","text":"On peut assigner une valeur \u00e0 plusieurs variables simultan\u00e9ment. Exemple : >>> x = y = 7 On peut aussi effectuer des affectations parall\u00e8les \u00e0 l\u2019aide d\u2019un seul op\u00e9rateur : >>> a, b = 4, 8.33","title":"Affectations multiples"},{"location":"1_Langage%20et%20programmation/Base_python/#les-bonne-pratique-de-nommage","text":"Un nom de variable est une s\u00e9quence de lettres (a \u2192 z , A \u2192 Z) et de chiffres (0 \u2192 9), qui doit toujours commencer par une lettre. Seules les lettres ordinaires sont autoris\u00e9es. Les lettres accentu\u00e9es, les c\u00e9dilles, les espaces, les caract\u00e8res sp\u00e9ciaux tels que $, #, @, etc. sont interdits, \u00e0 l\u2019exception du caract\u00e8re _ (soulign\u00e9). La casse est significative (les caract\u00e8res majuscules et minuscules sont distingu\u00e9s). Le nommage des variables doit \u00eatre le plus explicite possible afin de simplifier la compr\u00e9hension du programme Le nom d\u2019une variable commence toujours par une minuscule Vous ne pouvez pas utiliser comme nom de variables les 33 \u00ab mots r\u00e9serv\u00e9s \u00bb ci-dessous ( utilis\u00e9s par le langage lui-m\u00eame) : and as assert break class continue def del elif else except False finally for from global if import in is lambda None nonlocal not or pass raise return True try while with yield","title":"Les bonne pratique de nommage"},{"location":"1_Langage%20et%20programmation/Base_python/#le-test","text":"Si nous voulons pouvoir \u00e9crire des applications v\u00e9ritablement utiles, il nous faut des technique permettant d\u2019aiguiller le d\u00e9roulement du programme dans diff\u00e9rentes directions, en fonction des circonstances rencontr\u00e9es. En Python, la syntaxe d\u2019une instruction conditionnelle est la suivante : if expression : Instruction1 Instruction2 Instruction3 else : Instruction4 Instruction5 Remarquez les points suivants : la ligne de test commence par if , et la condition est suivie d\u2019un deux points (indispensable, sinon Python arr\u00eatera le script avec une erreur de syntaxe). les instructions 1 , 2 et 3 sont celles qui seront ex\u00e9cut\u00e9es si la condition est vraie ( True ) Ces instructions doivent \u00eatre indent\u00e9es (d\u00e9cal\u00e9es vers la droite) du m\u00eame nombre de tabulation pour indiquer qu\u2019elles font partie du m\u00eame if . La partie else instruction4 instruction5 est facultative. Ces instructions seront ex\u00e9cut\u00e9es seulement si la condition qui suit le if est fausse ( False ) Le mot else doit \u00eatre suivi d\u2019un deux-points ; il doit \u00eatre align\u00e9 avec le if auquel il correspond. Lorsqu\u2019on veut encha\u00eener plusieurs tests, on peut utiliser l\u2019instruction elif , qui est la contraction de else if . Cette instruction doit \u00eatre align\u00e9e avec le if correspondant, et elle doit \u00eatre suivie d\u2019une condition, puis d\u2019un deux-points et apr\u00e8s d\u2019instructions indent\u00e9es, comme pour un if . Les instructions seront ex\u00e9cut\u00e9es si la condition qui suit le if est fausse, mais que la condition qui suit le elif est vraie.","title":"Le test"},{"location":"1_Langage%20et%20programmation/Base_python/#la-boucle","text":"En programmation, on appelle boucle un syst\u00e8me d\u2019instructions qui permet de r\u00e9p\u00e9ter un certain nombre de fois (voire ind\u00e9finiment) toute une s\u00e9rie d\u2019op\u00e9rations. Python propose deux instructions particuli\u00e8res pour construire des boucles : l\u2019instruction for et l\u2019instruction while","title":"La boucle"},{"location":"1_Langage%20et%20programmation/Base_python/#la-boucle-non-bornee-while","text":"Le mot while signifie \u00ab tant que \u00bb en anglais. Cette instruction r\u00e9p\u00e9te continuellement le bloc d\u2019instructions qui suit, tant que l\u2019expression est vraie. while expression : Instruction1 Instruction2 Instruction3 Instruction4 Instruction5","title":"La boucle non born\u00e9e While"},{"location":"1_Langage%20et%20programmation/Base_python/#la-boucle-bornee-for","text":"La syntaxe d\u2019une boucle for est la suivante : for i in range ( e , e \u2019 ) : Instruction1 Instruction2 Instruction3 Instruction4 i est une variable, e et e\u2019 sont des expressions et instruction1 , instructions2 sont des instructions, appel\u00e9e corps de cette boucle. C\u2019est lui qui va s\u2019ex\u00e9cuter autant de fois que pr\u00e9cis\u00e9 dans la boucle. Comme dans le cas des tests, le corps d\u2019une boucle doit \u00eatre indent\u00e9. Cette boucle a pour effet d\u2019ex\u00e9cuter le corps de boucle ( n - m ) fois, o\u00f9 m est la valeur de l\u2019expression e et n celle de l\u2019expression e\u2019 . Pour chaque tour de boucle la valeur de la variable i est successivement m , m+1 , ..., n\u22121 . Par exemple, ex\u00e9cuter la boucle : for i in range ( 1 , 11 ): print ( \"all\u00f4 \" , end = \"\" ) print ( \"t\u2019es o\u00f9 ?\" ) * a pour effet d\u2019afficher : all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 all\u00f4 t'es o\u00f9 ?","title":"la boucle born\u00e9e for"},{"location":"1_Langage%20et%20programmation/Base_python/#choisir-entre-une-boucle-for-et-la-boucle-while","text":"Si on conna\u00eet \u00e0 l\u2019avance le nombre de r\u00e9p\u00e9titions \u00e0 effectuer, la boucle for est toute indiqu\u00e9e. \u00c0 l\u2019inverse, si la d\u00e9cision d\u2019arr\u00eater la boucle ne peut s\u2019exprimer que par un test, c\u2019est la boucle while qu\u2019il faut choisir.","title":"Choisir entre une boucle for et la boucle while"},{"location":"1_Langage%20et%20programmation/Interactions_utilisateur/","text":"Les int\u00e9ractions utilisateur (entr\u00e9es/sorties) Format PDF Dans l\u2019ex\u00e9cution d\u2019un programme, il est fr\u00e9quent que l\u2019utilisateur ait besoin de saisir des informations. Les fonctions particuli\u00e8res print() et input() permettent d\u2019int\u00e9ragir avec l\u2019utilisateur. La fonction print() La fonction print() sert \u00e0 afficher du texte et/ou le contenu d\u2019une variable. >>> print ( 'Bienvenue au cours de NSI.' ) Bienvenue au cours de NSI . >>> prenom = 'Boris' >>> print ( 'Bonjour' , prenom , ', bienvenue au cours de NSI.' ) Bonjour Boris , bienvenue au cours de NSI . Remarques Pour afficher plusieurs donn\u00e9es avec la fonction print(), il suffit de les s\u00e9parer avec des virgules. La fonction print() effectue un retour \u00e0 la ligne apr\u00e8s l\u2019affichage du texte. Ce retour \u00e0 la ligne peut \u00eatre inhib\u00e9 avec le param\u00e8tre end='' . for i in range ( 3 ) : print ( i ) Affiche 0 1 2 for i in range ( 3 ) : print ( i , end = '' ) Affiche 012 La fonction input() La fonction input() permet des int\u00e9raction avec l\u2019utilisateur : elle va stopper l\u2019ex\u00e9cution du programme et attendre que l\u2019utilisateur saisisse une donn\u00e9e. Le programme reprend lorsque l\u2019utilisateur appuie sur la touche ENTREE . La fonction renvoie alors le texte saisi par l\u2019utilisateur. L\u2019instruction suivante aura pour effet d\u2019ouvrir une zone de saisie dans laquelle l\u2019utilisateur pourra entrer une valeur. Cette valeur sera affect\u00e9e \u00e0 la variable nom. nom = input ( 'Quel est votre nom ?' ) Remarque La valeur renvoy\u00e9e par la fonction input() est une cha\u00eene de caract\u00e8re (type str ). Pour obtenir un nombre entier, il faudra saisir : age = int ( input ( \u2018 'Quel est votre age ?' ))","title":"Les int\u00e9ractions avec l'utilisateur"},{"location":"1_Langage%20et%20programmation/Interactions_utilisateur/#les-interactions-utilisateur-entreessorties","text":"Format PDF Dans l\u2019ex\u00e9cution d\u2019un programme, il est fr\u00e9quent que l\u2019utilisateur ait besoin de saisir des informations. Les fonctions particuli\u00e8res print() et input() permettent d\u2019int\u00e9ragir avec l\u2019utilisateur.","title":"Les int\u00e9ractions utilisateur (entr\u00e9es/sorties)"},{"location":"1_Langage%20et%20programmation/Interactions_utilisateur/#la-fonction-print","text":"La fonction print() sert \u00e0 afficher du texte et/ou le contenu d\u2019une variable. >>> print ( 'Bienvenue au cours de NSI.' ) Bienvenue au cours de NSI . >>> prenom = 'Boris' >>> print ( 'Bonjour' , prenom , ', bienvenue au cours de NSI.' ) Bonjour Boris , bienvenue au cours de NSI . Remarques Pour afficher plusieurs donn\u00e9es avec la fonction print(), il suffit de les s\u00e9parer avec des virgules. La fonction print() effectue un retour \u00e0 la ligne apr\u00e8s l\u2019affichage du texte. Ce retour \u00e0 la ligne peut \u00eatre inhib\u00e9 avec le param\u00e8tre end='' . for i in range ( 3 ) : print ( i ) Affiche 0 1 2 for i in range ( 3 ) : print ( i , end = '' ) Affiche 012","title":"La fonction print()"},{"location":"1_Langage%20et%20programmation/Interactions_utilisateur/#la-fonction-input","text":"La fonction input() permet des int\u00e9raction avec l\u2019utilisateur : elle va stopper l\u2019ex\u00e9cution du programme et attendre que l\u2019utilisateur saisisse une donn\u00e9e. Le programme reprend lorsque l\u2019utilisateur appuie sur la touche ENTREE . La fonction renvoie alors le texte saisi par l\u2019utilisateur. L\u2019instruction suivante aura pour effet d\u2019ouvrir une zone de saisie dans laquelle l\u2019utilisateur pourra entrer une valeur. Cette valeur sera affect\u00e9e \u00e0 la variable nom. nom = input ( 'Quel est votre nom ?' ) Remarque La valeur renvoy\u00e9e par la fonction input() est une cha\u00eene de caract\u00e8re (type str ). Pour obtenir un nombre entier, il faudra saisir : age = int ( input ( \u2018 'Quel est votre age ?' ))","title":"La fonction input()"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/","text":"Les cha\u00eenes de caract\u00e8res dans Python Une cha\u00eene de caract\u00e8res est une structure de donn\u00e9es composites . Une cha\u00eene de caract\u00e8res est form\u00e9e de plusieurs valeurs simples que sont ses diff\u00e9rents caract\u00e8res. Cette structure de donn\u00e9es est d\u00eetes immutable, c\u2019est \u00e0 dire qu\u2019il n\u2019est pas possible de la modifier sur place (impossibilit\u00e9 de rajouter ou retirer des caract\u00e8res). Pour modifier une cha\u00eene existante, on en extrait les parties appropri\u00e9es, et on reconstitue une nouvelle cha\u00eene \u00e0 l\u2019aide de l\u2019op\u00e9ration de concat\u00e9nation. D\u00e9claration d\u2019une cha\u00eene de caract\u00e8res Sous Python, on d\u00e9clare une chaine de caract\u00e8res enbordant le texte de guillemets (simple ou double quote) >>> a = 'Ceci est une chaine de caracteres' >>> a 'Ceci est une chaine de caracteres' Acc\u00e8s aux caract\u00e8res d\u2019une cha\u00eene de caract\u00e8res Puisqu\u2019une cha\u00eene de caract\u00e8re est une don\u00e9ne composite, il est possible d\u2019acc\u00e9der \u00e0 chaque caract\u00e8re la composant par son indice. Cette m\u00e9thode d\u2019acc\u00e8s est similaire \u00e0 celle utilis\u00e9e dans la manipulation de listes. L\u2019indice (ou index) du caract\u00e8re de la cha\u00eene est d\u00e9fini entre crochets. >>> a = 'Ceci est une chaine de caracteres' >>> a [ 0 ] 'C' >>> a [ 6 ] 's' >>> a [ - 1 ] 's' Le balayage d\u2019une cha\u00eene de caract\u00e8re Le balayage d\u2019une cha\u00eene de caract\u00e8re consiste \u00e0 lire successivement l\u2019ensemble des caract\u00e8res qu\u2019elle contient afin d\u2019\u00e9ventuellement op\u00e9rer un traitement. Cette op\u00e9ration peut \u00eatre r\u00e9alis\u00e9 avec une boucle for ayant la liste \u00e0 balayer comme argument. Dans l\u2019exemple suivant, la variable i prendra successivement les valeurs contenues dans le tableau. La boucle for sera donc ex\u00e9cut\u00e9es 9 fois puisque la cha\u00eene a contient 9 caract\u00e8res. 1 2 3 a = 'Ceci est ' for i in a : print ( i , end = \u2019\u2019 ) Equivalent \u00e0 : 1 2 3 a = 'Ceci est ' for i in range ( len ( a )): print ( a [ i ], end = \u2019\u2019 ) Op\u00e9ration sur les cha\u00eenes de caract\u00e8res Concat\u00e9nation et duplication Les cha\u00eenes de caract\u00e8res supportent l\u2019op\u00e9rateur + de concat\u00e9nation, ainsi que l\u2019op\u00e9rateur * pour la duplication : >>> a = 'Ceci est une ' >>> b = 'chaine de caracteres' >>> a + b 'Ceci est une chaine de caracteres' >>> a * 2 'Ceci est une Ceci est une ' Longueur d\u2019une cha\u00eene de caract\u00e8res La fonction len() permet de conna\u00eetre la longueur d\u2019une cha\u00eene de carct\u00e8res, c\u2019est-\u00e0-dire le nombre de caract\u00e8res qu\u2019elle contient. >>> a = 'toi' >>> len ( a ) 3 Test de pr\u00e9sence d\u2019un caract\u00e8re La pr\u00e9sence d\u2019un caract\u00e8re peut \u00eatre test\u00e9e avec la commande in >>> a = 'Ceci est ' >>> 'C' in a True >>> 'E' in a False Les tranches (slicing) Comme pour les listes, il est possible d\u2019extraire une partie d\u2019une cha\u00eene de caract\u00e8res en utilisant un indi\u00e7age construit sur le mod\u00e8le [m:n+1] pour r\u00e9cup\u00e9rer tous les \u00e9l\u00e9ments, du \u00e9mi\u00e8me au \u00e9ni\u00e8me (de l\u2019\u00e9l\u00e9ment m inclus \u00e0 l\u2019\u00e9l\u00e9ment n+1 exclu). >>> a = 'Ceci est ' >>> a [ 2 : 4 ] 'ci' >>> a [: 3 ] 'Cec' >>> a [: - 4 ] 'Ceci ' Comparaison de chaines Pour comparer des cha\u00eenes de caract\u00e8res, on utilise les op\u00e9rateurs == et <= cette derni\u00e8re relation comparant deux cha\u00eenes pour l\u2019ordre alphab\u00e9tique. >>> a = 'Ceci est ' >>> b = 'Cebi est ' >>> a == b False >>> b < a True","title":"Les cha\u00eenes de caract\u00e8res"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#les-chaines-de-caracteres-dans-python","text":"Une cha\u00eene de caract\u00e8res est une structure de donn\u00e9es composites . Une cha\u00eene de caract\u00e8res est form\u00e9e de plusieurs valeurs simples que sont ses diff\u00e9rents caract\u00e8res. Cette structure de donn\u00e9es est d\u00eetes immutable, c\u2019est \u00e0 dire qu\u2019il n\u2019est pas possible de la modifier sur place (impossibilit\u00e9 de rajouter ou retirer des caract\u00e8res). Pour modifier une cha\u00eene existante, on en extrait les parties appropri\u00e9es, et on reconstitue une nouvelle cha\u00eene \u00e0 l\u2019aide de l\u2019op\u00e9ration de concat\u00e9nation.","title":"Les cha\u00eenes de caract\u00e8res dans Python"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#declaration-dune-chaine-de-caracteres","text":"Sous Python, on d\u00e9clare une chaine de caract\u00e8res enbordant le texte de guillemets (simple ou double quote) >>> a = 'Ceci est une chaine de caracteres' >>> a 'Ceci est une chaine de caracteres'","title":"D\u00e9claration d\u2019une cha\u00eene de caract\u00e8res"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#acces-aux-caracteres-dune-chaine-de-caracteres","text":"Puisqu\u2019une cha\u00eene de caract\u00e8re est une don\u00e9ne composite, il est possible d\u2019acc\u00e9der \u00e0 chaque caract\u00e8re la composant par son indice. Cette m\u00e9thode d\u2019acc\u00e8s est similaire \u00e0 celle utilis\u00e9e dans la manipulation de listes. L\u2019indice (ou index) du caract\u00e8re de la cha\u00eene est d\u00e9fini entre crochets. >>> a = 'Ceci est une chaine de caracteres' >>> a [ 0 ] 'C' >>> a [ 6 ] 's' >>> a [ - 1 ] 's'","title":"Acc\u00e8s aux caract\u00e8res d\u2019une cha\u00eene de caract\u00e8res"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#le-balayage-dune-chaine-de-caractere","text":"Le balayage d\u2019une cha\u00eene de caract\u00e8re consiste \u00e0 lire successivement l\u2019ensemble des caract\u00e8res qu\u2019elle contient afin d\u2019\u00e9ventuellement op\u00e9rer un traitement. Cette op\u00e9ration peut \u00eatre r\u00e9alis\u00e9 avec une boucle for ayant la liste \u00e0 balayer comme argument. Dans l\u2019exemple suivant, la variable i prendra successivement les valeurs contenues dans le tableau. La boucle for sera donc ex\u00e9cut\u00e9es 9 fois puisque la cha\u00eene a contient 9 caract\u00e8res. 1 2 3 a = 'Ceci est ' for i in a : print ( i , end = \u2019\u2019 ) Equivalent \u00e0 : 1 2 3 a = 'Ceci est ' for i in range ( len ( a )): print ( a [ i ], end = \u2019\u2019 )","title":"Le balayage d\u2019une cha\u00eene de caract\u00e8re"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#operation-sur-les-chaines-de-caracteres","text":"","title":"Op\u00e9ration sur les cha\u00eenes de caract\u00e8res"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#concatenation-et-duplication","text":"Les cha\u00eenes de caract\u00e8res supportent l\u2019op\u00e9rateur + de concat\u00e9nation, ainsi que l\u2019op\u00e9rateur * pour la duplication : >>> a = 'Ceci est une ' >>> b = 'chaine de caracteres' >>> a + b 'Ceci est une chaine de caracteres' >>> a * 2 'Ceci est une Ceci est une '","title":"Concat\u00e9nation et duplication"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#longueur-dune-chaine-de-caracteres","text":"La fonction len() permet de conna\u00eetre la longueur d\u2019une cha\u00eene de carct\u00e8res, c\u2019est-\u00e0-dire le nombre de caract\u00e8res qu\u2019elle contient. >>> a = 'toi' >>> len ( a ) 3","title":"Longueur d\u2019une cha\u00eene de caract\u00e8res"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#test-de-presence-dun-caractere","text":"La pr\u00e9sence d\u2019un caract\u00e8re peut \u00eatre test\u00e9e avec la commande in >>> a = 'Ceci est ' >>> 'C' in a True >>> 'E' in a False","title":"Test de pr\u00e9sence d\u2019un caract\u00e8re"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#les-tranches-slicing","text":"Comme pour les listes, il est possible d\u2019extraire une partie d\u2019une cha\u00eene de caract\u00e8res en utilisant un indi\u00e7age construit sur le mod\u00e8le [m:n+1] pour r\u00e9cup\u00e9rer tous les \u00e9l\u00e9ments, du \u00e9mi\u00e8me au \u00e9ni\u00e8me (de l\u2019\u00e9l\u00e9ment m inclus \u00e0 l\u2019\u00e9l\u00e9ment n+1 exclu). >>> a = 'Ceci est ' >>> a [ 2 : 4 ] 'ci' >>> a [: 3 ] 'Cec' >>> a [: - 4 ] 'Ceci '","title":"Les tranches (slicing)"},{"location":"1_Langage%20et%20programmation/chainesCaracteres/#comparaison-de-chaines","text":"Pour comparer des cha\u00eenes de caract\u00e8res, on utilise les op\u00e9rateurs == et <= cette derni\u00e8re relation comparant deux cha\u00eenes pour l\u2019ordre alphab\u00e9tique. >>> a = 'Ceci est ' >>> b = 'Cebi est ' >>> a == b False >>> b < a True","title":"Comparaison de chaines"},{"location":"1_Langage%20et%20programmation/fonctions/","text":"Les fonctions Format PDF Les fonctions sont des bouts de code d'un programme qui sont ex\u00e9cut\u00e9s \u00e0 chaque fois qu'ils sont appel\u00e9s. Elles permettent de structurer le code, d\u2019\u00e9viter les redondances, de le rendre plus lisible dans le but d\u2019en faciliter la maintenance. L\u2019utilisation de fonctions fait partie des bonnes pratiques de la programmation. D\u00e9finition d\u2019une fonction def nom_fonction ( argument1 , argument2 , ... ) : # Code de la fonction return valeur de retour # Code hors fonction Appel d\u2019une fonction Consid\u00e9rons une fonction double qui multiplie par 2 la somme de deux nombres pass\u00e9s en param\u00e8tre. Une telle fonction s\u2019\u00e9crira : def double ( a , b ) : resultat = 2 * ( a + b ) return resultat L\u2019appel suivant de la fonction renvoie donc la valeur 24 (2*(4+8) = 24) >>> double(4,8) 24 Sp\u00e9cification d\u2019une fonction Une fonction prend des arguments en param\u00e8tre, les manipule et renvoie un r\u00e9sultat. Cette organisation d\u2019un programme permet la r\u00e9utilisation et le partage d\u2019algorithmes plus ou moins complexes. Cette notion de partage oblige les concepteurs de fonctions \u00e0 d\u00e9crire la fonction afin de sp\u00e9cifier : Le nom de l\u2019algorithme, La description des param\u00e8tres : quelles variables, quels types ... La description du r\u00e9sultat Cette sp\u00e9cification est r\u00e9alis\u00e9e au d\u00e9but de la fonction par l\u2019utilisation de docstrings . def puissance ( n , p ) : \"\"\" Calcul la puissance de p du nombre n arguments : n nombre reel* p nombre reel* retour : renvoie le resultat de n puissance p* \"\"\" return n ** p Remarque : Les docstrings sont cr\u00e9\u00e9s en apposant trois simples cotes au d\u00e9but du commentaires et trois autres d\u00e9cal\u00e9s d\u2019une tabulation. Port\u00e9e des variables Les variables locales Les variables d\u00e9finies \u00e0 l\u2019int\u00e9rieur de la fonction ont une port\u00e9e locale c\u2019est \u00e0 dire qu\u2019elles sont cr\u00e9\u00e9es \u00e0 l\u2019appel de la fonction et d\u00e9truites \u00e0 la sortie de la fonction. def ajoute_1 ( x ) : resultat = x + 1 return resultat Ici resultat, est une variable locale \u00e0 la fonction. Celle-ci n\u2019existe qu\u2019au sein de la fonction ajoute_1 et n\u2019est pas visible par le programme principal. Variable globale Par opposition aux variables locales, une variable globale est une variable cr\u00e9\u00e9e dans le programme principal (hors de toute fonction). Une variable globale est accessible partout : dans les fonctions et dans le programme principal. Par exemple, ce programme affiche la valeur 84 def double () : return 2 * v v = 42 w = double () print ( w ) On recommande cependant de ne pas d\u00e9finir de fonctions dont le code d\u00e9pend de variables globales dont la valeur peut changer. A l\u2019inverse, il est tout \u00e0 fait l\u00e9gitime d\u2019utiliser des variables globales pour stocker des constantes utilis\u00e9es dans des fonctions. Erreurs fr\u00e9quentes lors de la programmation de fonctions La d\u00e9finition de la fonction se termine par : La fonction doit \u00eatre document\u00e9e par l\u2019utilisation de docstrings. Cette documentation est indent\u00e9e par rapport \u00e0 la d\u00e9finition de la fonction. Le corps de la fonction doit \u00eatre indent\u00e9 Les variables locales ne doivent pas \u00eatre appel\u00e9es \u00e0 l\u2019ext\u00e9rieur de la fonction L\u2019instruction print n\u2019\u00e9quivaut pas \u00e0 un return. En effet print permet d\u2019afficher un r\u00e9sultat dans la console alors que return permet de sortir de la fonction et de renvoyer un r\u00e9sultat si besoin.","title":"Les fonctions"},{"location":"1_Langage%20et%20programmation/fonctions/#les-fonctions","text":"Format PDF Les fonctions sont des bouts de code d'un programme qui sont ex\u00e9cut\u00e9s \u00e0 chaque fois qu'ils sont appel\u00e9s. Elles permettent de structurer le code, d\u2019\u00e9viter les redondances, de le rendre plus lisible dans le but d\u2019en faciliter la maintenance. L\u2019utilisation de fonctions fait partie des bonnes pratiques de la programmation.","title":"Les fonctions"},{"location":"1_Langage%20et%20programmation/fonctions/#definition-dune-fonction","text":"def nom_fonction ( argument1 , argument2 , ... ) : # Code de la fonction return valeur de retour # Code hors fonction","title":"D\u00e9finition d\u2019une fonction"},{"location":"1_Langage%20et%20programmation/fonctions/#appel-dune-fonction","text":"Consid\u00e9rons une fonction double qui multiplie par 2 la somme de deux nombres pass\u00e9s en param\u00e8tre. Une telle fonction s\u2019\u00e9crira : def double ( a , b ) : resultat = 2 * ( a + b ) return resultat L\u2019appel suivant de la fonction renvoie donc la valeur 24 (2*(4+8) = 24) >>> double(4,8) 24","title":"Appel d\u2019une fonction"},{"location":"1_Langage%20et%20programmation/fonctions/#specification-dune-fonction","text":"Une fonction prend des arguments en param\u00e8tre, les manipule et renvoie un r\u00e9sultat. Cette organisation d\u2019un programme permet la r\u00e9utilisation et le partage d\u2019algorithmes plus ou moins complexes. Cette notion de partage oblige les concepteurs de fonctions \u00e0 d\u00e9crire la fonction afin de sp\u00e9cifier : Le nom de l\u2019algorithme, La description des param\u00e8tres : quelles variables, quels types ... La description du r\u00e9sultat Cette sp\u00e9cification est r\u00e9alis\u00e9e au d\u00e9but de la fonction par l\u2019utilisation de docstrings . def puissance ( n , p ) : \"\"\" Calcul la puissance de p du nombre n arguments : n nombre reel* p nombre reel* retour : renvoie le resultat de n puissance p* \"\"\" return n ** p Remarque : Les docstrings sont cr\u00e9\u00e9s en apposant trois simples cotes au d\u00e9but du commentaires et trois autres d\u00e9cal\u00e9s d\u2019une tabulation.","title":"Sp\u00e9cification d\u2019une fonction"},{"location":"1_Langage%20et%20programmation/fonctions/#portee-des-variables","text":"","title":"Port\u00e9e des variables"},{"location":"1_Langage%20et%20programmation/fonctions/#les-variables-locales","text":"Les variables d\u00e9finies \u00e0 l\u2019int\u00e9rieur de la fonction ont une port\u00e9e locale c\u2019est \u00e0 dire qu\u2019elles sont cr\u00e9\u00e9es \u00e0 l\u2019appel de la fonction et d\u00e9truites \u00e0 la sortie de la fonction. def ajoute_1 ( x ) : resultat = x + 1 return resultat Ici resultat, est une variable locale \u00e0 la fonction. Celle-ci n\u2019existe qu\u2019au sein de la fonction ajoute_1 et n\u2019est pas visible par le programme principal.","title":"Les variables locales"},{"location":"1_Langage%20et%20programmation/fonctions/#variable-globale","text":"Par opposition aux variables locales, une variable globale est une variable cr\u00e9\u00e9e dans le programme principal (hors de toute fonction). Une variable globale est accessible partout : dans les fonctions et dans le programme principal. Par exemple, ce programme affiche la valeur 84 def double () : return 2 * v v = 42 w = double () print ( w ) On recommande cependant de ne pas d\u00e9finir de fonctions dont le code d\u00e9pend de variables globales dont la valeur peut changer. A l\u2019inverse, il est tout \u00e0 fait l\u00e9gitime d\u2019utiliser des variables globales pour stocker des constantes utilis\u00e9es dans des fonctions.","title":"Variable globale"},{"location":"1_Langage%20et%20programmation/fonctions/#erreurs-frequentes-lors-de-la-programmation-de-fonctions","text":"La d\u00e9finition de la fonction se termine par : La fonction doit \u00eatre document\u00e9e par l\u2019utilisation de docstrings. Cette documentation est indent\u00e9e par rapport \u00e0 la d\u00e9finition de la fonction. Le corps de la fonction doit \u00eatre indent\u00e9 Les variables locales ne doivent pas \u00eatre appel\u00e9es \u00e0 l\u2019ext\u00e9rieur de la fonction L\u2019instruction print n\u2019\u00e9quivaut pas \u00e0 un return. En effet print permet d\u2019afficher un r\u00e9sultat dans la console alors que return permet de sortir de la fonction et de renvoyer un r\u00e9sultat si besoin.","title":"Erreurs fr\u00e9quentes lors de la programmation de fonctions"},{"location":"1_Langage%20et%20programmation/listes/Construction_listes/","text":"Construction de listes D\u00e9claration d\u2019une liste (rappel) Sous Python, on peut costruire une liste comme une collection d\u2019\u00e9l\u00e9ments s\u00e9par\u00e9s par des virgules, l\u2019ensemble \u00e9tant enferm\u00e9 dans des crochets. Exemple : >>> a = [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] >>> a [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] 0 La premi\u00e8re instruction cr\u00e9e une variable a dont le contenu fait r\u00e9f\u00e9rence \u00e0 une liste de 10 entiers. Construction de grandes listes Si on doit construire une liste vraiment grande, il devient difficile de le faire en \u00e9num\u00e9rant tous ses \u00e9l\u00e9ments. Diff\u00e9rentes mani\u00e8res d\u2019initailaiser la liste peuvent alors \u00eatre utilis\u00e9es. Construction d\u2019une liste avec une valeure unique. On peut utiliser l\u2019op\u00e9rateur * pour indiquer la longueur de la liste : >>> a = [ 0 ] * 1000 >>> len ( a ) 1000 >>> a [ 0 ] 0 >>> a [ - 1 ] 0 Listes par compr\u00e9hension La liste en compr\u00e9hension permet d'\u00e9crire des boucles for plus concises. Tr\u00e8s utiles d\u00e8s lors que l\u2019on souhaite cr\u00e9er une nouvelle liste bas\u00e9e sur une pr\u00e9-existante. Par exemple, on peut utiliser une liste en compr\u00e9hension pour cr\u00e9er une liste contenant les carr\u00e9s des 1000 premiers entiers. Classiquement ce programme peut s\u2019\u00e9crire : a = [ 0 ] * 1000 for i in range ( 1000 ) : a [ i ] = i * i Python propose une syntaxe simplifi\u00e9e pour combiner l\u2019allocation de la liste et son remplissage par la notation suivante : >>> a = [ i * i for i in range ( 1000 )] >>> a [ 0 , 1 , 4 , 9 , 16 , \u2026 , 996004 , 9988001 ] Cette nouvelle construction m\u00e9lange les crochets, qui explicitent la construction d\u2019une liste, et les mots-cl\u00e9s de la boucle for de Python, qui explicite le remplissage de la liste avec une boucle. Cette structure s\u2019appelle une liste par compr\u00e9hension. Dans cette construction, le parcours de la variable i n\u2019est pas limit\u00e9e \u00e0 un intervalle d\u2019entiers construits avec range. On peut parcourir une autre liste : >>> t = [ 3 * i + 1 for i in range ( 10 )] >>> a = [ x * x for x in t ] >>> t [ 1 , 4 , 7 , 10 , 13 , 16 , 19 , 22 , 25 , 28 ] >>> a [ 1 , 16 , 49 , 100 , 169 , 256 , 361 , 484 , 625 , 784 ] Il est possible de ne conserver que certaines valeurs prises par la variable, en ajoutant une condition bool\u00e9enne \u00e0 la compr\u00e9hension, avec le mot-cl\u00e9 if >>> a = [ i * i for i in range ( 30 ) if i % 4 == 1 ] >>> a [ 1 , 25 , 81 , 169 , 289 , 441 , 625 , 841 ]","title":"Construction de listes"},{"location":"1_Langage%20et%20programmation/listes/Construction_listes/#construction-de-listes","text":"","title":"Construction de listes"},{"location":"1_Langage%20et%20programmation/listes/Construction_listes/#declaration-dune-liste-rappel","text":"Sous Python, on peut costruire une liste comme une collection d\u2019\u00e9l\u00e9ments s\u00e9par\u00e9s par des virgules, l\u2019ensemble \u00e9tant enferm\u00e9 dans des crochets. Exemple : >>> a = [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] >>> a [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] 0 La premi\u00e8re instruction cr\u00e9e une variable a dont le contenu fait r\u00e9f\u00e9rence \u00e0 une liste de 10 entiers.","title":"D\u00e9claration d\u2019une liste (rappel)"},{"location":"1_Langage%20et%20programmation/listes/Construction_listes/#construction-de-grandes-listes","text":"Si on doit construire une liste vraiment grande, il devient difficile de le faire en \u00e9num\u00e9rant tous ses \u00e9l\u00e9ments. Diff\u00e9rentes mani\u00e8res d\u2019initailaiser la liste peuvent alors \u00eatre utilis\u00e9es.","title":"Construction de grandes listes"},{"location":"1_Langage%20et%20programmation/listes/Construction_listes/#construction-dune-liste-avec-une-valeure-unique","text":"On peut utiliser l\u2019op\u00e9rateur * pour indiquer la longueur de la liste : >>> a = [ 0 ] * 1000 >>> len ( a ) 1000 >>> a [ 0 ] 0 >>> a [ - 1 ] 0","title":"Construction d\u2019une liste avec une valeure unique."},{"location":"1_Langage%20et%20programmation/listes/Construction_listes/#listes-par-comprehension","text":"La liste en compr\u00e9hension permet d'\u00e9crire des boucles for plus concises. Tr\u00e8s utiles d\u00e8s lors que l\u2019on souhaite cr\u00e9er une nouvelle liste bas\u00e9e sur une pr\u00e9-existante. Par exemple, on peut utiliser une liste en compr\u00e9hension pour cr\u00e9er une liste contenant les carr\u00e9s des 1000 premiers entiers. Classiquement ce programme peut s\u2019\u00e9crire : a = [ 0 ] * 1000 for i in range ( 1000 ) : a [ i ] = i * i Python propose une syntaxe simplifi\u00e9e pour combiner l\u2019allocation de la liste et son remplissage par la notation suivante : >>> a = [ i * i for i in range ( 1000 )] >>> a [ 0 , 1 , 4 , 9 , 16 , \u2026 , 996004 , 9988001 ] Cette nouvelle construction m\u00e9lange les crochets, qui explicitent la construction d\u2019une liste, et les mots-cl\u00e9s de la boucle for de Python, qui explicite le remplissage de la liste avec une boucle. Cette structure s\u2019appelle une liste par compr\u00e9hension. Dans cette construction, le parcours de la variable i n\u2019est pas limit\u00e9e \u00e0 un intervalle d\u2019entiers construits avec range. On peut parcourir une autre liste : >>> t = [ 3 * i + 1 for i in range ( 10 )] >>> a = [ x * x for x in t ] >>> t [ 1 , 4 , 7 , 10 , 13 , 16 , 19 , 22 , 25 , 28 ] >>> a [ 1 , 16 , 49 , 100 , 169 , 256 , 361 , 484 , 625 , 784 ] Il est possible de ne conserver que certaines valeurs prises par la variable, en ajoutant une condition bool\u00e9enne \u00e0 la compr\u00e9hension, avec le mot-cl\u00e9 if >>> a = [ i * i for i in range ( 30 ) if i % 4 == 1 ] >>> a [ 1 , 25 , 81 , 169 , 289 , 441 , 625 , 841 ]","title":"Listes par compr\u00e9hension"},{"location":"1_Langage%20et%20programmation/listes/listes/","text":"Les listes Format PDF Dans de nombreuses situations, on a besoin d\u2019utiliser des valeurs qui, comme les textes, les images ou les sons, sont form\u00e9es de plusieurs nombres ou de plusieurs bool\u00e9ens. Ces valeurs sont dites des donn\u00e9es composites. . Sous python le nom de liste est utilis\u00e9. D\u00e9claration d\u2019une liste Sous Python, on peut d\u00e9finir une liste comme une collection d\u2019\u00e9l\u00e9ments s\u00e9par\u00e9s par des virgules, l\u2019ensemble \u00e9tant enferm\u00e9 dans des crochets. Exemple Structure d'une liste >>> a = [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] >>> a [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] La premi\u00e8re instruction cr\u00e9e une variable a dont le contenu fait r\u00e9f\u00e9rence \u00e0 une liste de 10 entiers. Acc\u00e8s aux donn\u00e9es d\u2019une liste Un des gros avantages d\u2019une liste est que l\u2019on peut appeler ses \u00e9l\u00e9ments par leur position. Ce num\u00e9ro est appel\u00e9 indice (ou index) de la liste. On acc\u00e8de \u00e0 une case d\u2019une liste avec l\u2019expression NomVariable[index] . nomVariable correspond au nom de la bo\u00eete, dont le contenu est la r\u00e9f\u00e9rence \u00e0 la liste \u00e0 n cases et index est une expression dont la valeur est un nombre entier compris entre 0 et n \u2013 1 . Index d\u2019une liste La num\u00e9rotation des indexs d\u2019une liste de n \u00e9l\u00e9ments commence \u00e0 partir de z\u00e9ro et se termine \u00e0 n-1. Mais la liste peut \u00e9galement \u00eatre index\u00e9e avec des nombres n\u00e9gatifs. Les indices n\u00e9gatifs reviennent \u00e0 compter \u00e0 partir de la fin. Leur principal avantage estest de pouvoir acc\u00e9der au dernier \u00e9l\u00e9ment d\u2019une liste \u00e0 l\u2019aide de l\u2019indice -1 sans pour autant conna\u00eetre la longueur de cette liste. L\u2019avant dernier \u00e9l\u00e9ment a lui l\u2019indice -2 , l\u2019avant-avant dernier l\u2019indice -3 , etc. Indices d'un tableau >>> a = [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] >>> a [ 0 ] 1 >>> a [ 6 ] 785 >>> a [ - 1 ] 87 Les tranches (slicing) Un autre avantage des listes est la possibilit\u00e9 de s\u00e9lectionner une partie d\u2019une liste en utilisant un indi\u00e7age construit sur le mod\u00e8le [m : n+1] pour r\u00e9cup\u00e9rer tous les \u00e9l\u00e9ments, du \u00e9mi\u00e8me au \u00e9ni\u00e8me (de l\u2019\u00e9l\u00e9ment m inclus \u00e0 l\u2019\u00e9l\u00e9ment n+1 exclu). On dit alors qu\u2019on r\u00e9cup\u00e8re une tranche de la liste, par exemple : >>> a = [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] >>> a [ 2 : 4 ] [ 2 , 3 ] >>> a [: 3 ] [ 1 , 10 , 2 ] >>> a [: - 4 ] [ 1 , 10 , 2 , 3 , 56 , 89 ] Op\u00e9ration sur les listes Le balayage d\u2019une liste Le balyage d\u2019une liste consiste \u00e0 lire successivement l\u2019ensemble des valeurs contenues dans une liste afin d\u2019\u00e9ventuellement op\u00e9rer un traitement. Cette op\u00e9ration peut \u00eatre r\u00e9alis\u00e9 avec une boucle for ayant la liste \u00e0 balayer comme argument. Dans l\u2019exemple suivant, la variable i prendra successivement les valeurs contenues dans le tableau. La boucle for sera donc ex\u00e9cut\u00e9es 4 fois puisque la liste a contient 4 \u00e9l\u00e9ments.","title":"Les listes"},{"location":"1_Langage%20et%20programmation/listes/listes/#les-listes","text":"Format PDF Dans de nombreuses situations, on a besoin d\u2019utiliser des valeurs qui, comme les textes, les images ou les sons, sont form\u00e9es de plusieurs nombres ou de plusieurs bool\u00e9ens. Ces valeurs sont dites des donn\u00e9es composites. . Sous python le nom de liste est utilis\u00e9.","title":"Les listes"},{"location":"1_Langage%20et%20programmation/listes/listes/#declaration-dune-liste","text":"Sous Python, on peut d\u00e9finir une liste comme une collection d\u2019\u00e9l\u00e9ments s\u00e9par\u00e9s par des virgules, l\u2019ensemble \u00e9tant enferm\u00e9 dans des crochets. Exemple Structure d'une liste >>> a = [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] >>> a [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] La premi\u00e8re instruction cr\u00e9e une variable a dont le contenu fait r\u00e9f\u00e9rence \u00e0 une liste de 10 entiers.","title":"D\u00e9claration d\u2019une liste"},{"location":"1_Langage%20et%20programmation/listes/listes/#acces-aux-donnees-dune-liste","text":"Un des gros avantages d\u2019une liste est que l\u2019on peut appeler ses \u00e9l\u00e9ments par leur position. Ce num\u00e9ro est appel\u00e9 indice (ou index) de la liste. On acc\u00e8de \u00e0 une case d\u2019une liste avec l\u2019expression NomVariable[index] . nomVariable correspond au nom de la bo\u00eete, dont le contenu est la r\u00e9f\u00e9rence \u00e0 la liste \u00e0 n cases et index est une expression dont la valeur est un nombre entier compris entre 0 et n \u2013 1 .","title":"Acc\u00e8s aux donn\u00e9es d\u2019une liste"},{"location":"1_Langage%20et%20programmation/listes/listes/#index-dune-liste","text":"La num\u00e9rotation des indexs d\u2019une liste de n \u00e9l\u00e9ments commence \u00e0 partir de z\u00e9ro et se termine \u00e0 n-1. Mais la liste peut \u00e9galement \u00eatre index\u00e9e avec des nombres n\u00e9gatifs. Les indices n\u00e9gatifs reviennent \u00e0 compter \u00e0 partir de la fin. Leur principal avantage estest de pouvoir acc\u00e9der au dernier \u00e9l\u00e9ment d\u2019une liste \u00e0 l\u2019aide de l\u2019indice -1 sans pour autant conna\u00eetre la longueur de cette liste. L\u2019avant dernier \u00e9l\u00e9ment a lui l\u2019indice -2 , l\u2019avant-avant dernier l\u2019indice -3 , etc. Indices d'un tableau >>> a = [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] >>> a [ 0 ] 1 >>> a [ 6 ] 785 >>> a [ - 1 ] 87","title":"Index d\u2019une liste"},{"location":"1_Langage%20et%20programmation/listes/listes/#les-tranches-slicing","text":"Un autre avantage des listes est la possibilit\u00e9 de s\u00e9lectionner une partie d\u2019une liste en utilisant un indi\u00e7age construit sur le mod\u00e8le [m : n+1] pour r\u00e9cup\u00e9rer tous les \u00e9l\u00e9ments, du \u00e9mi\u00e8me au \u00e9ni\u00e8me (de l\u2019\u00e9l\u00e9ment m inclus \u00e0 l\u2019\u00e9l\u00e9ment n+1 exclu). On dit alors qu\u2019on r\u00e9cup\u00e8re une tranche de la liste, par exemple : >>> a = [ 1 , 10 , 2 , 3 , 56 , 89 , 785 , 41 , 25 , 87 ] >>> a [ 2 : 4 ] [ 2 , 3 ] >>> a [: 3 ] [ 1 , 10 , 2 ] >>> a [: - 4 ] [ 1 , 10 , 2 , 3 , 56 , 89 ]","title":"Les tranches (slicing)"},{"location":"1_Langage%20et%20programmation/listes/listes/#operation-sur-les-listes","text":"","title":"Op\u00e9ration sur les listes"},{"location":"1_Langage%20et%20programmation/listes/listes/#le-balayage-dune-liste","text":"Le balyage d\u2019une liste consiste \u00e0 lire successivement l\u2019ensemble des valeurs contenues dans une liste afin d\u2019\u00e9ventuellement op\u00e9rer un traitement. Cette op\u00e9ration peut \u00eatre r\u00e9alis\u00e9 avec une boucle for ayant la liste \u00e0 balayer comme argument. Dans l\u2019exemple suivant, la variable i prendra successivement les valeurs contenues dans le tableau. La boucle for sera donc ex\u00e9cut\u00e9es 4 fois puisque la liste a contient 4 \u00e9l\u00e9ments.","title":"Le balayage d\u2019une liste"},{"location":"2_Representation_information/entiers_positifs/","text":"Repr\u00e9sentation des nombres entiers positifs Format PDF Les repr\u00e9sentations \u00e9crites d\u2019un nombre sont multiples ; elles varient selon les cultures. On distingue principalement deux types d\u2019\u00e9critures : Ecriture \u00e0 base de symboles Le principe repose sur l\u2019addition (et parfois soustraction) de symboles repr\u00e9sentant des nombres. Par exemple : \u2022 La num\u00e9ration m\u00e9sopotamienne, 3000 ans av J.C. \u2022 La num\u00e9ration romaine \u2192 MMXIX = 2019 Ecriture \u00e0 base de rang (ou de position). Ce principe d\u2019\u00e9criture est utilis\u00e9 actuellement tous les jours 2019 = 2 x 1000 + 0 x 100 + 1 x 10 + 9 x 1. Ou encore : 2019 est \u00e9gal \u00e0 2 milliers, 0 centaines, 1 dizaine, 9 unit\u00e9s. Actuellement dans la vie quotidienne, la base 10 (d\u00e9cimale) est utilis\u00e9e (nous avons 10 doigts) alors que dans les ordinateurs repr\u00e9sentent les nombres selon la base 2 (les composants de bases utilis\u00e9s peuvent prendre deux \u00e9tats). Les nombres en base 2 sont repr\u00e9sent\u00e9s avec beaucoup de caract\u00e8res (32 caract\u00e8res et plus) ce qui rend fastidieux leur \u00e9criture. En cons\u00e9quence lors de l\u2019\u00e9tude de syst\u00e8mes informatiques, l\u2019utilisation de la base 16 (hexad\u00e9cimal) est privil\u00e9gi\u00e9e pour simplifier l\u2019\u00e9criture. Concept d\u2019une repr\u00e9sentation num\u00e9rique par base Les nombres que nous utilisons sont compos\u00e9s de chiffres c pond\u00e9r\u00e9s dans une base b. Dans une base b, il existe b-1 chiffres repr\u00e9sent\u00e9s par des symboles distincts. On peut donc g\u00e9n\u00e9raliser la forme d\u2019\u00e9criture d\u2019un nombre ainsi : La base d\u00e9cimales (base 10) Ce syst\u00e8me de num\u00e9ration, utilise dans la vie quotidienne, dispose de 10 symboles diff\u00e9rents : 0, 1, 2, 3, 4, 5, 6, 7, 8 et 9 . On parle de base 10. Un nombre entier positif N s\u2019\u00e9crit en base 10 : \\[ N_{10} = N = c_{n\u22121} \\times 10^{n\u22121} + c_{n\u22122} \\times 10^{n\u22122} + ... + c_{1} \\times 10^{1} + c_{0} \\times 10^{0} \\] Pour sp\u00e9cifier la base utilis\u00e9e, on place g\u00e9n\u00e9ralement le nombre entier positif suivi de la base utilis\u00e9e en indice. Exemple : \\[ 7 239_{10} = 7 239 = 7 \\times 10^3 + 2 \\times 10^2 + 3 \\times 10^1 + 9 \\ times 10^0 \\] Pour la base 10, on oublie souvent de sp\u00e9cifier la base car il s'agit de la base de num\u00e9ration utilis\u00e9e quotidiennement. Les digits correspondent aux coefficients cn. Ils ne peuvent prendre que des valeurs appartenant \u00e0 la base. Les poids sont les puissances de 10. Le poids est \u00e9gal \u00e0 la base \u00e9lev\u00e9e \u00e0 la puissance de son rang. Num\u00e9ration binaire (base 2) La num\u00e9ration binaire ou en base 2 utilise deux symboles : 0 et 1 . Cette base est tr\u00e8s commode pour distinguer les deux \u00e9tats logiques fondamentaux (Lampe allum\u00e9e ou \u00e9teinte, pr\u00e9sence ou non dans une pi\u00e8ce, couleur noir ou blanc...), et est tr\u00e8s utilis\u00e9e en informatique. On \u00e9crit : \\[ N = c_{n\u22121} \\times 2^{n\u22121} + c_{n\u22122} \\times 2^{n\u22122} + ... + c_{1} \\times 2^{1} + c_{0} \\times 2^{0} \\] Exemple : Que repr\u00e9sente la valeur 10000101\u2082 ? \\(10000101_2 = 1 \\times 2^7 + 0 \\times 2^6 + 0 \\times 2^5 + 0 \\times 2^4 + 0\\times 2^3 + 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0\\) ce qui vaut 133 En num\u00e9ration binaire, les digits ( \\(c_i\\) ) sont appel\u00e9s bit (abreviation de Binary digIT). Un code binaire \u00e0 n bits distingue \\(2^n\\) \u00e9tats ou combinaisons et la valeur la plus grande repr\u00e9sentable vaut \\(2^{n-1}\\) Le bit de poids le plus fort ( \\(c_{n-1}\\) ) est appel\u00e9 MSB (Most Significant Bit). Le bit de poids le plus faible ( \\(c_0\\) ) est appel\u00e9 LSB (Low Significant Bit). Un regroupement successif de 4 bits s'appelle un quartet . Un regroupement successif de 8 bits s'appelle un octet . Un regroupement successif de k bits (k > 8) s'appelle un mot de k bits. Num\u00e9ration hexad\u00e9cimale (base 16) Ce syst\u00e8me de num\u00e9ration est tr\u00e8s utilis\u00e9 dans l\u2019analyse du fonctionnement de syst\u00e8mes ordinateurs et micro-ordinateurs ainsi que dans le domaine des transmissions de donn\u00e9es. Cette base correspond \u00e0 une contraction d\u2019\u00e9criture de la base 2. Il comporte 16 symboles : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F . Pour indiquer la base 16, on peut utiliser le caract\u00e8re $ (dollar) devant le nombre, ou alors 16# devant le nombre. Exemple : \\(A8_{16}\\) = 16#A8 = $A8 On \u00e9crit : \\[ N = c_{n\u22121} \\times 16^{n\u22121} + c_{n\u22122} \\times 16^{n\u22122} + ... + c_{1} \\times 16^{1} + c_{0} \\times 16^{0} \\] Exemple : Que repr\u00e9sente la valeur $A8 ? \\(A8_{16} =10 \\times 16^1 + 8 \\times 16^0\\) ce qui vaut 168 Les changements de base Conversions directes Du binaire vers l'hexad\u00e9cimal_ : Pour convertir du binaire vers l'hexad\u00e9cimal, on divise le nombre binaire en quartet, en partant de la droite. Chacun des paquets est ensuite converti en hexad\u00e9cimal. Exemple : 110101110001\u2082 = 1101 0111 0001\u2082 = 16#D71 De l'hexad\u00e9cimal vers le binaire : C'est le processus directement inverse, on \u00e9crit chaque quartet sur 4 bits en binaire en compl\u00e9tant \u00e9ventuellement avec des z\u00e9ros sur la gauche. Exemple : 1C3516 = 0001 1100 0011 0101\u2082 Conversions indirectes Un nombre entier positif N \u00e9tant donn\u00e9 en base 10, on cherche \u00e0 l'\u00e9crire dans une autre base not\u00e9e b. La m\u00e9thode consiste \u00e0 diviser le nombre d\u00e9cimal N par b et \u00e0 conserver le reste (division enti\u00e8re). Le quotient obtenu est ainsi successivement divis\u00e9 tant qu'il n'est pas nul. Les restes successifs sont \u00e9crits, en commen\u00e7ant par le dernier, de la gauche vers la droite, pour former l'expression de N dans le syst\u00e8me de base b. Du d\u00e9cimal vers le binaire Exemple pour la conversion de 173 en base 2, il faut effectuer des divisions successives par 2 Divisions successives par 2 le r\u00e9sultat est donc 17310 \u2192 10101101\u2082 Du d\u00e9cimal vers l'hexad\u00e9cimal : On reprend la m\u00eame m\u00e9thode mais en divisant par 16 : Divisions successives par 16 le r\u00e9sultat est donc 17310 \u2192 $AD. Remarque : La division euclidienne \u00e9tant source d\u2019erreur de calcul, il est conseill\u00e9 d\u2019effectuer la conversion en base 2 du nombre en base 10 puis de convertir le nombre binaire en base 16.","title":"Repr\u00e9sentation des entiers positifs"},{"location":"2_Representation_information/entiers_positifs/#representation-des-nombres-entiers-positifs","text":"Format PDF Les repr\u00e9sentations \u00e9crites d\u2019un nombre sont multiples ; elles varient selon les cultures. On distingue principalement deux types d\u2019\u00e9critures : Ecriture \u00e0 base de symboles Le principe repose sur l\u2019addition (et parfois soustraction) de symboles repr\u00e9sentant des nombres. Par exemple : \u2022 La num\u00e9ration m\u00e9sopotamienne, 3000 ans av J.C. \u2022 La num\u00e9ration romaine \u2192 MMXIX = 2019 Ecriture \u00e0 base de rang (ou de position). Ce principe d\u2019\u00e9criture est utilis\u00e9 actuellement tous les jours 2019 = 2 x 1000 + 0 x 100 + 1 x 10 + 9 x 1. Ou encore : 2019 est \u00e9gal \u00e0 2 milliers, 0 centaines, 1 dizaine, 9 unit\u00e9s. Actuellement dans la vie quotidienne, la base 10 (d\u00e9cimale) est utilis\u00e9e (nous avons 10 doigts) alors que dans les ordinateurs repr\u00e9sentent les nombres selon la base 2 (les composants de bases utilis\u00e9s peuvent prendre deux \u00e9tats). Les nombres en base 2 sont repr\u00e9sent\u00e9s avec beaucoup de caract\u00e8res (32 caract\u00e8res et plus) ce qui rend fastidieux leur \u00e9criture. En cons\u00e9quence lors de l\u2019\u00e9tude de syst\u00e8mes informatiques, l\u2019utilisation de la base 16 (hexad\u00e9cimal) est privil\u00e9gi\u00e9e pour simplifier l\u2019\u00e9criture.","title":"Repr\u00e9sentation des nombres entiers positifs"},{"location":"2_Representation_information/entiers_positifs/#concept-dune-representation-numerique-par-base","text":"Les nombres que nous utilisons sont compos\u00e9s de chiffres c pond\u00e9r\u00e9s dans une base b. Dans une base b, il existe b-1 chiffres repr\u00e9sent\u00e9s par des symboles distincts. On peut donc g\u00e9n\u00e9raliser la forme d\u2019\u00e9criture d\u2019un nombre ainsi :","title":"Concept d\u2019une repr\u00e9sentation num\u00e9rique par base"},{"location":"2_Representation_information/entiers_positifs/#la-base-decimales-base-10","text":"Ce syst\u00e8me de num\u00e9ration, utilise dans la vie quotidienne, dispose de 10 symboles diff\u00e9rents : 0, 1, 2, 3, 4, 5, 6, 7, 8 et 9 . On parle de base 10. Un nombre entier positif N s\u2019\u00e9crit en base 10 : \\[ N_{10} = N = c_{n\u22121} \\times 10^{n\u22121} + c_{n\u22122} \\times 10^{n\u22122} + ... + c_{1} \\times 10^{1} + c_{0} \\times 10^{0} \\] Pour sp\u00e9cifier la base utilis\u00e9e, on place g\u00e9n\u00e9ralement le nombre entier positif suivi de la base utilis\u00e9e en indice. Exemple : \\[ 7 239_{10} = 7 239 = 7 \\times 10^3 + 2 \\times 10^2 + 3 \\times 10^1 + 9 \\ times 10^0 \\] Pour la base 10, on oublie souvent de sp\u00e9cifier la base car il s'agit de la base de num\u00e9ration utilis\u00e9e quotidiennement. Les digits correspondent aux coefficients cn. Ils ne peuvent prendre que des valeurs appartenant \u00e0 la base. Les poids sont les puissances de 10. Le poids est \u00e9gal \u00e0 la base \u00e9lev\u00e9e \u00e0 la puissance de son rang.","title":"La base d\u00e9cimales (base 10)"},{"location":"2_Representation_information/entiers_positifs/#numeration-binaire-base-2","text":"La num\u00e9ration binaire ou en base 2 utilise deux symboles : 0 et 1 . Cette base est tr\u00e8s commode pour distinguer les deux \u00e9tats logiques fondamentaux (Lampe allum\u00e9e ou \u00e9teinte, pr\u00e9sence ou non dans une pi\u00e8ce, couleur noir ou blanc...), et est tr\u00e8s utilis\u00e9e en informatique. On \u00e9crit : \\[ N = c_{n\u22121} \\times 2^{n\u22121} + c_{n\u22122} \\times 2^{n\u22122} + ... + c_{1} \\times 2^{1} + c_{0} \\times 2^{0} \\] Exemple : Que repr\u00e9sente la valeur 10000101\u2082 ? \\(10000101_2 = 1 \\times 2^7 + 0 \\times 2^6 + 0 \\times 2^5 + 0 \\times 2^4 + 0\\times 2^3 + 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0\\) ce qui vaut 133 En num\u00e9ration binaire, les digits ( \\(c_i\\) ) sont appel\u00e9s bit (abreviation de Binary digIT). Un code binaire \u00e0 n bits distingue \\(2^n\\) \u00e9tats ou combinaisons et la valeur la plus grande repr\u00e9sentable vaut \\(2^{n-1}\\) Le bit de poids le plus fort ( \\(c_{n-1}\\) ) est appel\u00e9 MSB (Most Significant Bit). Le bit de poids le plus faible ( \\(c_0\\) ) est appel\u00e9 LSB (Low Significant Bit). Un regroupement successif de 4 bits s'appelle un quartet . Un regroupement successif de 8 bits s'appelle un octet . Un regroupement successif de k bits (k > 8) s'appelle un mot de k bits.","title":"Num\u00e9ration binaire (base 2)"},{"location":"2_Representation_information/entiers_positifs/#numeration-hexadecimale-base-16","text":"Ce syst\u00e8me de num\u00e9ration est tr\u00e8s utilis\u00e9 dans l\u2019analyse du fonctionnement de syst\u00e8mes ordinateurs et micro-ordinateurs ainsi que dans le domaine des transmissions de donn\u00e9es. Cette base correspond \u00e0 une contraction d\u2019\u00e9criture de la base 2. Il comporte 16 symboles : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F . Pour indiquer la base 16, on peut utiliser le caract\u00e8re $ (dollar) devant le nombre, ou alors 16# devant le nombre. Exemple : \\(A8_{16}\\) = 16#A8 = $A8 On \u00e9crit : \\[ N = c_{n\u22121} \\times 16^{n\u22121} + c_{n\u22122} \\times 16^{n\u22122} + ... + c_{1} \\times 16^{1} + c_{0} \\times 16^{0} \\] Exemple : Que repr\u00e9sente la valeur $A8 ? \\(A8_{16} =10 \\times 16^1 + 8 \\times 16^0\\) ce qui vaut 168","title":"Num\u00e9ration hexad\u00e9cimale (base 16)"},{"location":"2_Representation_information/entiers_positifs/#les-changements-de-base","text":"","title":"Les changements de base"},{"location":"2_Representation_information/entiers_positifs/#conversions-directes","text":"Du binaire vers l'hexad\u00e9cimal_ : Pour convertir du binaire vers l'hexad\u00e9cimal, on divise le nombre binaire en quartet, en partant de la droite. Chacun des paquets est ensuite converti en hexad\u00e9cimal. Exemple : 110101110001\u2082 = 1101 0111 0001\u2082 = 16#D71 De l'hexad\u00e9cimal vers le binaire : C'est le processus directement inverse, on \u00e9crit chaque quartet sur 4 bits en binaire en compl\u00e9tant \u00e9ventuellement avec des z\u00e9ros sur la gauche. Exemple : 1C3516 = 0001 1100 0011 0101\u2082","title":"Conversions directes"},{"location":"2_Representation_information/entiers_positifs/#conversions-indirectes","text":"Un nombre entier positif N \u00e9tant donn\u00e9 en base 10, on cherche \u00e0 l'\u00e9crire dans une autre base not\u00e9e b. La m\u00e9thode consiste \u00e0 diviser le nombre d\u00e9cimal N par b et \u00e0 conserver le reste (division enti\u00e8re). Le quotient obtenu est ainsi successivement divis\u00e9 tant qu'il n'est pas nul. Les restes successifs sont \u00e9crits, en commen\u00e7ant par le dernier, de la gauche vers la droite, pour former l'expression de N dans le syst\u00e8me de base b. Du d\u00e9cimal vers le binaire Exemple pour la conversion de 173 en base 2, il faut effectuer des divisions successives par 2 Divisions successives par 2 le r\u00e9sultat est donc 17310 \u2192 10101101\u2082 Du d\u00e9cimal vers l'hexad\u00e9cimal : On reprend la m\u00eame m\u00e9thode mais en divisant par 16 : Divisions successives par 16 le r\u00e9sultat est donc 17310 \u2192 $AD. Remarque : La division euclidienne \u00e9tant source d\u2019erreur de calcul, il est conseill\u00e9 d\u2019effectuer la conversion en base 2 du nombre en base 10 puis de convertir le nombre binaire en base 16.","title":"Conversions indirectes"}]}